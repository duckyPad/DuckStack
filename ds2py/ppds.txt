_NEEDS_EPILOGUE = 6
_DEFAULTDELAY = 20
_DEFAULTCHARDELAY = 5
_CHARJITTER = 10
_ALLOW_ABORT = 1
_DONT_REPEAT = 0
DELAY 600
OLED_CLEAR
OLED_CURSOR 0 0
OLED_PRINT duckyScript Compiler Workout
OLED_CURSOR 0 12
OLED_PRINT KeyID=$_THIS_KEYID
OLED_CURSOR 0 24
OLED_PRINT Model=$_DP_MODEL
OLED_CURSOR 0 36
OLED_PRINT t(ms)=$_TIME_MS
OLED_LINE 0 49 127 49
OLED_RECT 0 52 45 63 1
OLED_CIRCLE 105 57 5 0
OLED_UPDATE
SWC_FILL 8 8 8
SWC_SET 1 255 0 0
SWC_SET 2 0 255 0
SWC_SET 3 0 0 255
DELAY 120
SWC_RESET 1
SWC_RESET 2
SWC_RESET 3
STRINGLN ==== duckyScript Compiler Workout ====
STRINGLN If you can read this, typing works.
STRINGLN This is a STRINGLN_BLOCK.
STRINGLN Each line should type and press ENTER.
STRINGLN Line 3: symbols !@#$%^&*()_+-=[]{};':",.<>/?
STRING This is a STRING_BLOCK: it should not press ENTER between lines,
STRING but it *should* type all text as-is.
KEYDOWN ENTER
KEYUP ENTER
VAR a = 7
VAR b = 3
VAR add = a + b
VAR sub = a - b
VAR mul = a * b
VAR div = a / b
VAR mod = a % b
VAR pow = a ** b
VAR bit_and = a & b
VAR bit_or  = a | b
VAR bit_xor = a ^ b
VAR shl = a << 2
VAR shr = 128 >> 3
VAR gt0 = a > 0
VAR lt0 = b < 0
VAR logic_and = gt0  and  lt0
VAR logic_or  = gt0  or  lt0
STRINGLN a=$a b=$b
STRINGLN add=$add sub=$sub mul=$mul div=$div mod=$mod pow=$pow
STRINGLN and=$bit_and or=$bit_or xor=$bit_xor shl=$shl shr=$shr
STRINGLN gt0=$gt0 lt0=$lt0 &&=$logic_and ||=$logic_or
VAR foo = 65409
VAR neg = 0 - 127
_STR_PRINT_FORMAT = 0
STRINGLN fmt0 unsigned foo=$foo
_STR_PRINT_FORMAT = 1
STRINGLN fmt1 signed foo=$foo neg=$neg
_STR_PRINT_FORMAT = 2
STRINGLN fmt2 hex-lower foo=$foo
_STR_PRINT_FORMAT = 3
STRINGLN fmt3 HEX-UPPER foo=$foo
_STR_PRINT_FORMAT = 0
_STR_PRINT_PADDING = 2
VAR year = 2025
VAR month = 8
VAR day = 5
STRINGLN padded date $year-$month-$day
_STR_PRINT_PADDING = 0
VAR amount = 100
DELAY amount*2+5
STRINGLN REPEAT demo line
STRINGLN REPEAT demo line
STRINGLN REPEAT demo line
STRINGLN REPEAT demo line
_RANDOM_MIN = 10
_RANDOM_MAX = 20
VAR r = _RANDOM_INT
STRINGLN random[10..20]=$r
_GV0 = _GV0 + 1
STRINGLN persistent _GV0 now=$_GV0
_KEYPRESS_COUNT = 0
STRINGLN keypress_count reset to $_KEYPRESS_COUNT
VAR spam = mod
IF spam == 0 THEN
    STRINGLN spam==0 branch
ELSE IF spam == 1 THEN
    STRINGLN spam==1 branch
ELSE
    STRINGLN spam==other branch (spam=$spam)
END_IF
VAR i = 0
WHILE i < 8
    i = i + 1
    IF i == 3 THEN
        STRINGLN i=$i -> CONTINUE
        CONTINUE
    END_IF
    STRINGLN loop i=$i
    IF i == 6 THEN
        STRINGLN i=$i -> LBREAK
        LBREAK
    END_IF
END_WHILE
FUNCTION clamp(v, lo, hi)
    IF v < lo THEN
        RETURN lo
    END_IF
    IF v > hi THEN
        RETURN hi
    END_IF
    RETURN v
END_FUNCTION
FUNCTION fib(n)
    VAR fa = 0
    VAR fb = 1
    VAR k = 0
    WHILE k < n
        VAR t = fa + fb
        fa = fb
        fb = t
        k = k + 1
    END_WHILE
    RETURN fa
END_FUNCTION
FUNCTION is_even(x)
    IF x % 2 == 0 THEN
        RETURN 1
    END_IF
    RETURN 0
END_FUNCTION
VAR c1 = clamp(5, 0, 10)
VAR c2 = clamp(0 - 5, 0, 10)
VAR c3 = clamp(50, 0, 10)
STRINGLN clamp: $c1 $c2 $c3
VAR f10 = fib(10)
STRINGLN fib(10)=$f10
VAR e7 = is_even(7)
VAR e8 = is_even(8)
STRINGLN even(7)=$e7 even(8)=$e8
IF 0 THEN
    KEYDOWN CTRL
    KEYDOWN c
    KEYUP c
    KEYUP CTRL
    KEYDOWN CTRL
    KEYDOWN v
    KEYUP v
    KEYUP CTRL
    KEYDOWN WINDOWS
    KEYUP WINDOWS
    KEYDOWN TAB
    KEYUP TAB
    KEYDOWN ESC
    KEYUP ESC
    KEYDOWN F1
    KEYUP F1
    KEYDOWN MK_MUTE
    KEYUP MK_MUTE
    KEYDOWN ALT
    KEYDOWN KP_1
    KEYUP KP_1
    KEYDOWN KP_7
    KEYUP KP_7
    KEYDOWN KP_2
    KEYUP KP_2
    KEYUP ALT
    MOUSE_MOVE 20 10
    KEYDOWN LMOUSE
    KEYUP LMOUSE
    MOUSE_WHEEL -3
    KEYDOWN RMOUSE
    KEYUP RMOUSE
    NEXT_PROFILE
    PREV_PROFILE
    GOTO_PROFILE NumPad
    DP_SLEEP
END_IF
OLED_RESTORE
SWC_RESET 99
STRINGLN ==== DONE ====
HALT
