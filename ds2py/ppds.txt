VAR global_counter = 100
FUNCTION factorial(n)
    VAR local_n = n
    IF local_n <= 1 THEN
        RETURN 1
    END_IF
    VAR next_n = local_n - 1
    VAR recurse_result = factorial(next_n)
    VAR result = local_n * recurse_result
    RETURN result
END_FUNCTION
FUNCTION flow_test(limit)
    VAR i = 0
    VAR sum = 0
    WHILE 1
        i = i + 1
        IF i > limit THEN
            STRINGLN [Flow] Limit reached, breaking...
            LBREAK
        END_IF
        IF i == 3 THEN
            STRINGLN [Flow] Skipping 3 (Continue check)...
            CONTINUE
        END_IF
        VAR is_even = i % 2
        IF is_even == 0 THEN
            CONTINUE
        ELSE
            sum = sum + i
            STRINGLN [Flow] Added odd number: $i
        END_IF
    END_WHILE
    RETURN sum
END_FUNCTION
STRINGLN =========================
STRINGLN STARTING COMPILER TEST
STRINGLN =========================
STRINGLN [Test 1] Recursion (Factorial 5)...
VAR fact_input = 5
VAR fact_res = factorial(fact_input)
STRINGLN Result: $fact_res
IF fact_res == 120 THEN
    STRINGLN >> SUCCESS: Recursion holds up.
ELSE
    STRINGLN >> FAILURE: Expected 120. Stack likely corrupted.
END_IF
STRINGLN -------------------------
STRINGLN [Test 2] Complex Flow (Sum odds to 7, skip 3)...
VAR flow_res = flow_test(7)
STRINGLN Result: $flow_res
IF flow_res == 13 THEN
    STRINGLN >> SUCCESS: Control flow logic is sound.
ELSE
    STRINGLN >> FAILURE: Expected 13. Jump targets likely wrong.
END_IF
STRINGLN -------------------------
STRINGLN [Test 3] Scope Check...
STRINGLN Global Var is: $global_counter
IF global_counter == 100 THEN
    STRINGLN >> SUCCESS: Globals preserved.
ELSE
    STRINGLN >> FAILURE: Global var overwritten by stack operations.
END_IF
STRINGLN =========================
STRINGLN TEST COMPLETE
STRINGLN =========================
