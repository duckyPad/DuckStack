REM --- Part 1: Signed Math Tests ---
REM Default mode is signed (or set to 0)
_UNSIGNED_MATH = 0
_STR_PRINT_FORMAT = 1

STRINGLN --- SIGNED MATH (Default) ---

REM Test 1: Right Shift (Arithmetic Shift)
REM -16 is binary 1111...10000. 
REM Signed shift preserves the sign bit (fills with 1s).
VAR val_neg = -16
VAR res_shift = val_neg >> 1
STRINGLN Signed Shift (-16 >> 1): $res_shift

REM Test 2: Division
VAR res_div = val_neg / 2
STRINGLN Signed Div (-16 / 2): $res_div

REM Test 3: Modulo
REM In signed math, result usually follows the sign of the dividend
VAR res_mod = -10 % 3
STRINGLN Signed Mod (-10 % 3): $res_mod

REM Test 4: Power
VAR res_pow = (-2) ** 2
STRINGLN Signed Pow (-2 ^ 2): $res_pow

STRINGLN 

REM --- Part 2: Unsigned Math Tests ---
REM Set Reserved Variable to 1 to enable Unsigned Math
_UNSIGNED_MATH = 1
_STR_PRINT_FORMAT = 0

STRINGLN --- UNSIGNED MATH ---

REM Reuse -16. In 32-bit unsigned, -16 is 4294967280 (0xFFFFFFF0)
VAR u_val = -16

REM Test 1: Right Shift (Logical Shift)
REM Unsigned shift does NOT preserve sign (fills with 0s).
VAR u_shift = u_val >> 1
STRINGLN Unsigned Shift (0xFFFFFFF0 >> 1): $u_shift

REM Test 2: Division
REM 4294967280 / 2
VAR u_div = u_val / 2
STRINGLN Unsigned Div (0xFFFFFFF0 / 2): $u_div

REM Test 3: Modulo
REM 4294967280 % 17. 
VAR u_mod = u_val % 17
STRINGLN Unsigned Mod (0xFFFFFFF0 % 17): $u_mod

REM Test 4: Power
REM 2^31 is 2147483648.
REM In signed 32-bit, this overflows to -2147483648.
REM In unsigned, it remains positive 2147483648.
VAR base = 2
VAR exp = 31
VAR u_pow = base ** exp
STRINGLN Unsigned Pow (2 ^ 31): $u_pow

STRINGLN

REM --- Part 3: Print Formats ---
STRINGLN --- PRINT FORMATS ---

VAR test_val = -1

_STR_PRINT_FORMAT = 0
STRINGLN Format 0 (Unsigned): $test_val

_STR_PRINT_FORMAT = 1
STRINGLN Format 1 (Signed): $test_val

_STR_PRINT_FORMAT = 2
STRINGLN Format 2 (Hex Lower): $test_val

_STR_PRINT_FORMAT = 3
STRINGLN Format 3 (Hex Upper): $test_val