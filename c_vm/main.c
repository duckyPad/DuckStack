#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include "main.h"
#include <setjmp.h>

uint8_t str_print_format;
uint8_t str_print_padding;
uint8_t bin_buf[BIN_BUF_SIZE];
uint32_t defaultdelay_value;
uint32_t defaultchardelay_value;
uint32_t charjitter_value;
uint32_t rand_min, rand_max;
uint32_t loop_size;
uint8_t epilogue_actions;
uint8_t allow_abort;
uint8_t kb_led_status;
uint8_t last_stack_op_result;
uint8_t disable_autorepeat;
uint32_t pgv_buf[PGV_COUNT];
int16_t utc_offset_minutes;
const uint8_t dsvm_version = 2;
static jmp_buf jmpbuf;

// ---------------------------

/*
  AUTO GENERATED BY 
  print_C_opcode_len_lookup()
  print_C_opcode_def()
  IN
  dsvm_common.py
*/

#define OP_LEN_LOOKUP_SIZE 100
const uint8_t opcode_len_lookup[OP_LEN_LOOKUP_SIZE] = {
1, // [0] NOP
3, // [1] PUSHC16
3, // [2] PUSHI
3, // [3] PUSHR
3, // [4] POPI
3, // [5] POPR
3, // [6] BRZ
3, // [7] JMP
3, // [8] ALLOC
3, // [9] CALL
3, // [10] RET
1, // [11] HALT
255, // [12]
255, // [13]
255, // [14]
255, // [15]
255, // [16]
255, // [17]
255, // [18]
255, // [19]
255, // [20]
255, // [21]
255, // [22]
255, // [23]
255, // [24]
255, // [25]
255, // [26]
255, // [27]
255, // [28]
255, // [29]
255, // [30]
255, // [31]
1, // [32] EQ
1, // [33] NOTEQ
1, // [34] LT
1, // [35] LTE
1, // [36] GT
1, // [37] GTE
1, // [38] ADD
1, // [39] SUB
1, // [40] MULT
1, // [41] DIV
1, // [42] MOD
1, // [43] POW
1, // [44] LSHIFT
1, // [45] RSHIFT
1, // [46] BITOR
1, // [47] BITXOR
1, // [48] BITAND
1, // [49] LOGIAND
1, // [50] LOGIOR
255, // [51]
255, // [52]
255, // [53]
255, // [54]
1, // [55] BITINV
1, // [56] LOGINOT
1, // [57] USUB
255, // [58]
255, // [59]
255, // [60]
255, // [61]
255, // [62]
255, // [63]
1, // [64] DELAY
1, // [65] KDOWN
1, // [66] KUP
1, // [67] MSCL
1, // [68] MMOV
1, // [69] SWCF
1, // [70] SWCC
1, // [71] SWCR
1, // [72] STR
1, // [73] STRLN
1, // [74] OLED_CUSR
1, // [75] OLED_PRNT
1, // [76] OLED_UPDE
1, // [77] OLED_CLR
1, // [78] OLED_REST
1, // [79] OLED_LINE
1, // [80] OLED_RECT
1, // [81] OLED_CIRC
1, // [82] BCLR
1, // [83] PREVP
1, // [84] NEXTP
1, // [85] GOTOP
1, // [86] SLEEP
255, // [87]
255, // [88]
255, // [89]
255, // [90]
255, // [91]
255, // [92]
255, // [93]
255, // [94]
255, // [95]
255, // [96]
255, // [97]
255, // [98]
255, // [99]
};

#define OP_NOP 0
#define OP_PUSHC16 1
#define OP_PUSHI 2
#define OP_PUSHR 3
#define OP_POPI 4
#define OP_POPR 5
#define OP_BRZ 6
#define OP_JMP 7
#define OP_ALLOC 8
#define OP_CALL 9
#define OP_RET 10
#define OP_HALT 11
#define OP_EQ 32
#define OP_NOTEQ 33
#define OP_LT 34
#define OP_LTE 35
#define OP_GT 36
#define OP_GTE 37
#define OP_ADD 38
#define OP_SUB 39
#define OP_MULT 40
#define OP_DIV 41
#define OP_MOD 42
#define OP_POW 43
#define OP_LSHIFT 44
#define OP_RSHIFT 45
#define OP_BITOR 46
#define OP_BITXOR 47
#define OP_BITAND 48
#define OP_LOGIAND 49
#define OP_LOGIOR 50
#define OP_BITINV 55
#define OP_LOGINOT 56
#define OP_USUB 57
#define OP_DELAY 64
#define OP_KDOWN 65
#define OP_KUP 66
#define OP_MSCL 67
#define OP_MMOV 68
#define OP_SWCF 69
#define OP_SWCC 70
#define OP_SWCR 71
#define OP_STR 72
#define OP_STRLN 73
#define OP_OLED_CUSR 74
#define OP_OLED_PRNT 75
#define OP_OLED_UPDE 76
#define OP_OLED_CLR 77
#define OP_OLED_REST 78
#define OP_OLED_LINE 79
#define OP_OLED_RECT 80
#define OP_OLED_CIRC 81
#define OP_BCLR 82
#define OP_PREVP 83
#define OP_NEXTP 84
#define OP_GOTOP 85
#define OP_SLEEP 86
#define OP_VMVER 255

// ---------------------------

/*
  Stack grows from larger address to smaller address
  SP points to next available slot
*/
typedef struct
{
  uint8_t* sp;
  uint8_t* top_addr;
  uint8_t* lower_bound;
  uint16_t size_bytes;
} my_stack;

my_stack data_stack;

void stack_init(my_stack* ms, uint8_t* top_addr, uint16_t size_bytes)
{
  ms->top_addr = top_addr;
  ms->sp = top_addr - sizeof(uint32_t);
  ms->size_bytes = size_bytes;
  ms->lower_bound = ms->top_addr - ms->size_bytes;
  memset(ms->lower_bound, 0, size_bytes);
}

uint8_t stack_push(my_stack* ms, uint32_t in_value)
{
  if(ms->sp < ms->lower_bound)
    return EXE_STACK_OVERFLOW;
  memcpy(ms->sp, &in_value, sizeof(uint32_t));
  ms->sp -= sizeof(uint32_t);
  return EXE_OK;
}

uint8_t stack_pop(my_stack* ms, uint32_t *out_value)
{
  uint8_t* next_sp = ms->sp + sizeof(uint32_t);
  if(next_sp >= ms->top_addr)
    return EXE_STACK_UNDERFLOW;
  ms->sp += sizeof(uint32_t);
  if(out_value != NULL)
    memcpy(out_value, ms->sp, sizeof(uint32_t));
  return EXE_OK;
}

uint8_t read_byte(uint16_t addr)
{
  if (addr >= 0xf801 && addr <= 0xf9ff)
    longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
  if (addr >= 0xfc00 && addr <= 0xfcff)
    longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
  return bin_buf[addr];
}

void stack_print(my_stack* ms)
{
    printf("\n=== STACK DUMP ===\n");
    printf(" Size: %u bytes\n", ms->size_bytes);
    printf("  Ptr       |   Hex      |  Dec       | Marker\n");
    printf(" -----------+------------+------------+-------\n");

    // Start looking from the high address (Base) down to the SP
    // Note: We start at top_addr - 4 because top_addr is the exclusive upper bound
    uint8_t* current_ptr = ms->top_addr - sizeof(uint32_t);

    // If SP is at the initial position, the stack is empty
    if (ms->sp == (ms->top_addr - sizeof(uint32_t))) {
        printf(" [ EMPTY ]\n");
        printf(" %p |            |            | <--- SP (Next Slot)\n", (void*)ms->sp);
        printf("==================\n\n");
        return;
    }

    // Iterate downwards until we hit the SP
    while (current_ptr > ms->sp)
    {
        uint32_t val;
        // Use memcpy to prevent alignment faults, matching your push/pop logic
        memcpy(&val, current_ptr, sizeof(uint32_t));

        printf(" %p | 0x%08X | %-10u |", (void*)current_ptr, val, val);

        if (current_ptr == ms->top_addr - sizeof(uint32_t)) {
            printf(" <--- BASE");
        }
        
        // The last pushed value is located right above the current SP
        if (current_ptr == ms->sp + sizeof(uint32_t)) {
            printf(" <--- TOP (Last Data)");
        }

        printf("\n");
        
        // Move to the next 32-bit slot (downwards)
        current_ptr -= sizeof(uint32_t);
    }

    // Show where the SP is currently pointing (the next empty slot)
    printf(" %p | [FREESLOT] |            | <--- SP (Next Slot)\n", (void*)ms->sp);
    printf("==================\n\n");
}

uint16_t make_uint16(uint8_t b0, uint8_t b1)
{
  return b0 | (b1 << 8);
}

uint32_t make_uint32(uint8_t* base_addr)
{
  // little endian, [0] lsb, [3] msb
    return  (uint32_t)base_addr[0]        |
           ((uint32_t)base_addr[1] << 8)  |
           ((uint32_t)base_addr[2] << 16) |
           ((uint32_t)base_addr[3] << 24);
}

uint8_t load_dsb(char* dsb_path, uint32_t* dsb_size)
{
  FILE *dsb_file = fopen(dsb_path, "r");
  if(dsb_file == NULL)
    return EXE_DSB_FOPEN_FAIL;
  memset(bin_buf, 0, BIN_BUF_SIZE);
  *dsb_size = fread(bin_buf, 1, BIN_BUF_SIZE, dsb_file);
  fclose(dsb_file);
  if(*dsb_size == 0)
    return EXE_DSB_FREAD_ERROR;
  if(bin_buf[0] != OP_VMVER)
    return EXE_DSB_INCOMPATIBLE_VERSION;
  if(bin_buf[1] != dsvm_version)
    return EXE_DSB_INCOMPATIBLE_VERSION;
  return EXE_OK;
}

uint8_t inst_size_lookup(uint8_t opcode)
{
  if(opcode == OP_VMVER)
    return 3;
  if(opcode >= OP_LEN_LOOKUP_SIZE || opcode_len_lookup[opcode] > MAX_INSTRUCTION_LEN)
    longjmp(jmpbuf, EXE_ILLEGAL_INSTRUCTION);
  return opcode_len_lookup[opcode];
}

void execute_instruction(uint16_t curr_pc, exe_context* exe)
{
  uint8_t opcode = read_byte(curr_pc);
  uint8_t instruction_size_bytes = inst_size_lookup(opcode);
  uint16_t payload = 0;
  exe->next_pc += instruction_size_bytes;

  printf("PC: %04d    Opcode: %02d", curr_pc, opcode);
  if(instruction_size_bytes == 3)
  {
    payload = make_uint16(read_byte(curr_pc+1), read_byte(curr_pc+2));
    printf("    Payload: %04x\n", payload);
  }
  else
  {
    printf("\n");
  }

  if(opcode == OP_NOP || opcode == OP_VMVER)
  {
    return;
  }
  else if(opcode == OP_PUSHC16)
  {
    stack_push(&data_stack, payload);
  }
}

void run_dsb(exe_context* er, char* dsb_path)
{
  uint32_t this_dsb_size = 0;
  uint8_t dsb_load_result = load_dsb(dsb_path, &this_dsb_size);
  if(dsb_load_result)
  {
    printf("DSB load fail: %d\n", dsb_load_result);
    er->result = dsb_load_result;
    return;
  }

  uint16_t current_pc = 0;
  uint16_t data_stack_size_bytes = DATA_STACK_START_ADDRESS - this_dsb_size - STACK_MOAT_SIZE;
  printf("DSB size: %d Bytes\n", this_dsb_size);
  printf("Stack size: %d Bytes\n", data_stack_size_bytes);
  stack_init(&data_stack, &bin_buf[DATA_STACK_START_ADDRESS], data_stack_size_bytes);

  int panic_code = setjmp(jmpbuf);
  if(panic_code != 0)
  {
    printf("VM Crashed! Panic: %d\n", panic_code);
    return;
  }
  
  while(1)
  {
    execute_instruction(current_pc, er);
    current_pc = er->next_pc;
    if(current_pc > this_dsb_size)
      break;
  }
  printf("execution done\n");
}

exe_context execon;

int main()
{
  run_dsb(&execon, "../ds2py/out.dsb");
  return 0;
}