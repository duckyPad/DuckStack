#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include "main.h"
#include <setjmp.h>

uint8_t str_print_format;
uint8_t str_print_padding;
uint8_t bin_buf[BIN_BUF_SIZE] __attribute__((aligned(4)));
uint32_t defaultdelay_value;
uint32_t defaultchardelay_value;
uint32_t charjitter_value;
uint32_t rand_min, rand_max;
uint32_t loop_size;
uint8_t epilogue_actions;
uint8_t allow_abort;
uint8_t kb_led_status;
uint8_t disable_autorepeat;
uint32_t pgv_buf[PGV_COUNT];
int16_t utc_offset_minutes;
const uint8_t dsvm_version = 2;
static jmp_buf jmpbuf;
uint8_t this_key_id = 127;

// ---------------------------

/*
  AUTO GENERATED BY 
  print_C_opcode_len_lookup()
  print_C_opcode_def()
  IN
  dsvm_common.py
*/

#define OP_LEN_LOOKUP_SIZE 100
const uint8_t opcode_len_lookup[OP_LEN_LOOKUP_SIZE] = {
1, // [0] NOP
3, // [1] PUSHC16
3, // [2] PUSHI
3, // [3] PUSHR
3, // [4] POPI
3, // [5] POPR
3, // [6] BRZ
3, // [7] JMP
3, // [8] ALLOC
3, // [9] CALL
3, // [10] RET
1, // [11] HALT
255, // [12]
255, // [13]
255, // [14]
255, // [15]
255, // [16]
255, // [17]
255, // [18]
255, // [19]
255, // [20]
255, // [21]
255, // [22]
255, // [23]
255, // [24]
255, // [25]
255, // [26]
255, // [27]
255, // [28]
255, // [29]
255, // [30]
255, // [31]
1, // [32] EQ
1, // [33] NOTEQ
1, // [34] LT
1, // [35] LTE
1, // [36] GT
1, // [37] GTE
1, // [38] ADD
1, // [39] SUB
1, // [40] MULT
1, // [41] DIV
1, // [42] MOD
1, // [43] POW
1, // [44] LSHIFT
1, // [45] RSHIFT
1, // [46] BITOR
1, // [47] BITXOR
1, // [48] BITAND
1, // [49] LOGIAND
1, // [50] LOGIOR
255, // [51]
255, // [52]
255, // [53]
255, // [54]
1, // [55] BITINV
1, // [56] LOGINOT
1, // [57] USUB
255, // [58]
255, // [59]
255, // [60]
255, // [61]
255, // [62]
255, // [63]
1, // [64] DELAY
1, // [65] KDOWN
1, // [66] KUP
1, // [67] MSCL
1, // [68] MMOV
1, // [69] SWCF
1, // [70] SWCC
1, // [71] SWCR
1, // [72] STR
1, // [73] STRLN
1, // [74] OLED_CUSR
1, // [75] OLED_PRNT
1, // [76] OLED_UPDE
1, // [77] OLED_CLR
1, // [78] OLED_REST
1, // [79] OLED_LINE
1, // [80] OLED_RECT
1, // [81] OLED_CIRC
1, // [82] BCLR
1, // [83] PREVP
1, // [84] NEXTP
1, // [85] GOTOP
1, // [86] SLEEP
255, // [87]
255, // [88]
255, // [89]
255, // [90]
255, // [91]
255, // [92]
255, // [93]
255, // [94]
255, // [95]
255, // [96]
255, // [97]
255, // [98]
255, // [99]
};

#define OP_NOP 0
#define OP_PUSHC16 1
#define OP_PUSHI 2
#define OP_PUSHR 3
#define OP_POPI 4
#define OP_POPR 5
#define OP_BRZ 6
#define OP_JMP 7
#define OP_ALLOC 8
#define OP_CALL 9
#define OP_RET 10
#define OP_HALT 11
#define OP_EQ 32
#define OP_NOTEQ 33
#define OP_LT 34
#define OP_LTE 35
#define OP_GT 36
#define OP_GTE 37
#define OP_ADD 38
#define OP_SUB 39
#define OP_MULT 40
#define OP_DIV 41
#define OP_MOD 42
#define OP_POW 43
#define OP_LSHIFT 44
#define OP_RSHIFT 45
#define OP_BITOR 46
#define OP_BITXOR 47
#define OP_BITAND 48
#define OP_LOGIAND 49
#define OP_LOGIOR 50
#define OP_BITINV 55
#define OP_LOGINOT 56
#define OP_USUB 57
#define OP_DELAY 64
#define OP_KDOWN 65
#define OP_KUP 66
#define OP_MSCL 67
#define OP_MMOV 68
#define OP_SWCF 69
#define OP_SWCC 70
#define OP_SWCR 71
#define OP_STR 72
#define OP_STRLN 73
#define OP_OLED_CUSR 74
#define OP_OLED_PRNT 75
#define OP_OLED_UPDE 76
#define OP_OLED_CLR 77
#define OP_OLED_REST 78
#define OP_OLED_LINE 79
#define OP_OLED_RECT 80
#define OP_OLED_CIRC 81
#define OP_BCLR 82
#define OP_PREVP 83
#define OP_NEXTP 84
#define OP_GOTOP 85
#define OP_SLEEP 86
#define OP_VMVER 255

// ---------------------------

my_stack data_stack;

// vm_stack_base: The virtual address where stack starts (e.g., 0xF7FF)
void stack_init(my_stack* ms, uint8_t* ram_base, uint16_t vm_stack_base, uint16_t size_bytes)
{
    // 1. Store the host memory base
    ms->ram_base = ram_base;

    // 2. Align the virtual base address (rounding down to nearest 4-byte boundary)
    //    If vm_stack_base is 0xF7FF, this becomes 0xF7FC
    uint16_t aligned_base = vm_stack_base & ~0x03;

    // 3. Set bounds
    ms->upper_bound = aligned_base; 
    ms->lower_bound = aligned_base - size_bytes;

    // 4. Initialize registers
    //    Matches your original logic: SP points to the current empty slot.
    //    We start "one slot down" so the first write occupies the top-most aligned bytes.
    ms->sp = ms->upper_bound - sizeof(uint32_t); 
    ms->fp = ms->upper_bound;

    // 5. Clear memory (Translation: Host Addr = ram_base + virtual_offset)
    memset(ms->ram_base + ms->lower_bound, 0, size_bytes);
}

void stack_push(my_stack* ms, uint32_t in_value)
{
  if (ms->sp < ms->lower_bound) 
    longjmp(jmpbuf, EXE_STACK_OVERFLOW);
  uint8_t* host_addr = ms->ram_base + ms->sp;
  memcpy(host_addr, &in_value, sizeof(uint32_t));
  ms->sp -= sizeof(uint32_t);
}

void stack_pop(my_stack* ms, uint32_t *out_value)
{
  uint16_t next_sp = ms->sp + sizeof(uint32_t);
  if (next_sp >= ms->upper_bound)
    longjmp(jmpbuf, EXE_STACK_UNDERFLOW);
  ms->sp = next_sp;
  uint8_t* host_addr = ms->ram_base + ms->sp;
  if(out_value != NULL)
    memcpy(out_value, host_addr, sizeof(uint32_t));
}

uint8_t read_byte(uint16_t addr)
{
  return bin_buf[addr];
}

void stack_write_fp_rel(my_stack* ms, int16_t offset, uint32_t value)
{
  if (offset & 0x03)
    longjmp(jmpbuf, EXE_UNALIGNED_ACCESS);
  uint16_t target_addr = ms->fp + offset;
  if (target_addr < ms->lower_bound || target_addr > (ms->upper_bound - sizeof(uint32_t)))
    longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
  uint8_t* host_addr = ms->ram_base + target_addr;
  memcpy(host_addr, &value, sizeof(uint32_t));
}

void stack_read_fp_rel(my_stack* ms, int16_t offset, uint32_t* value)
{
  if (offset & 0x03)
    longjmp(jmpbuf, EXE_UNALIGNED_ACCESS);

  uint16_t target_addr = ms->fp + offset;
  if (target_addr < ms->lower_bound || target_addr > (ms->upper_bound - sizeof(uint32_t)))
    longjmp(jmpbuf, EXE_ILLEGAL_ADDR);

  uint8_t* host_addr = ms->ram_base + target_addr;
  memcpy(value, host_addr, sizeof(uint32_t));
}

void stack_print(my_stack* ms, char* comment)
{
  if(PRINT_DEBUG == 0)
    return;
  printf("\n=== STACK STATE: %s ===\n", comment);
  printf("------------------------\n");

  // 1. Start iteration directly at SP (The Free Slot)
  //    We loop from SP (Low Address) up to Upper Bound (High Address)
  uint16_t current_v_addr = ms->sp;

  // 2. Iterate
  while (current_v_addr <= ms->upper_bound)
  {
    // Translate Virtual Addr -> Host Addr
    uint8_t* host_addr = ms->ram_base + current_v_addr;
    
    // Read value safely (Note: For the free slot, this is technically garbage/uninitialized data)
    uint32_t val;
    memcpy(&val, host_addr, sizeof(uint32_t));

    // Print Line: [Addr]  HexValue
    printf(" [0x%04X]  0x%08X  ", current_v_addr, val);

    // 3. Special handling for the SP (Free Slot) vs Data Slots
    if (current_v_addr == ms->sp) 
    {
      // This is the empty slot waiting for the next push
      printf("<----------------------- SP");
    }
    else 
    {
      // This is actual data
      printf("(%10d)", val);
      // Mark the actual Top of Stack data (the item most recently pushed)
      if (current_v_addr == ms->sp + sizeof(uint32_t))
        printf("  [TOS]");
    }

    // Add visual markers for Frame Pointer
    if (current_v_addr == ms->fp)
      printf(" <--- FP");
    // Mark the Stack Bottom (First item pushed)
    if (current_v_addr == ms->upper_bound)
      printf("  [BOTTOM]");
    printf("\n");
    // Move to the next item (higher address)
    current_v_addr += sizeof(uint32_t);
  }
  printf("========================\n\n");
}

uint32_t binop_equal(uint32_t a, uint32_t b) {return a == b;}
uint32_t binop_not_equal(uint32_t a, uint32_t b) {return a != b;}
uint32_t binop_lower(uint32_t a, uint32_t b) {return a < b;}
uint32_t binop_lower_eq(uint32_t a, uint32_t b) {return a <= b;}
uint32_t binop_greater(uint32_t a, uint32_t b) {return a > b;}
uint32_t binop_greater_eq(uint32_t a, uint32_t b) {return a >= b;}
uint32_t binop_add(uint32_t a, uint32_t b) {return a + b;}
uint32_t binop_sub(uint32_t a, uint32_t b) {return a - b;}
uint32_t binop_mul(uint32_t a, uint32_t b) {return a * b;}
uint32_t binop_mod(uint32_t a, uint32_t b) {return a % b;}
uint32_t binop_lshift(uint32_t a, uint32_t b) {return a << b;}
uint32_t binop_rshift(uint32_t a, uint32_t b) {return a >> b;}
uint32_t binop_bitwise_or(uint32_t a, uint32_t b) {return a | b;}
uint32_t binop_bitwise_xor(uint32_t a, uint32_t b) {return a ^ b;}
uint32_t binop_bitwise_and(uint32_t a, uint32_t b) {return a & b;}
uint32_t binop_logical_and(uint32_t a, uint32_t b) {return a && b;}
uint32_t binop_logical_or(uint32_t a, uint32_t b) {return a || b;}

uint32_t binop_divide(uint32_t a, uint32_t b)
{
  if(b == 0)
    longjmp(jmpbuf, EXE_DIVISION_BY_ZERO);
  return a/b;
}

uint32_t binop_power(uint32_t x, uint32_t exponent)
{
  uint32_t result = 1;
  for (int i = 0; i < exponent; ++i)
    result *= x;
  return result;
}

uint32_t unaop_bit_inv(uint32_t value) {return ~value;}
uint32_t unaop_logical_not(uint32_t value) {return !value;}
uint32_t unaop_usub(uint32_t value) {return value * -1;}

void binop(FUNC_PTR_BINOP bin_func)
{
  uint32_t rhs, lhs;
  stack_pop(&data_stack, &rhs);
  stack_pop(&data_stack, &lhs);
  stack_push(&data_stack, bin_func(lhs, rhs));
  stack_print(&data_stack, "AFTER BINOP");
}

void unaryop(FUNC_PTR_UNARY una_func)
{
  uint32_t value;
  stack_pop(&data_stack, &value);
  stack_push(&data_stack, una_func(value));
  stack_print(&data_stack, "AFTER UNAOP");
}

uint16_t make_uint16(uint8_t b0, uint8_t b1)
{
  return b0 | (b1 << 8);
}

uint8_t is_pgv(uint16_t addr)
{
  return addr >= PGV_START_ADDRESS && addr <= PGV_END_ADDRESS_INCLUSIVE;
}

uint32_t make_uint32(const uint8_t* base_addr)
{
  uint32_t result;
  memcpy(&result, base_addr, sizeof(result)); 
  return result;
}

void write_uint32_as_4B(uint8_t* bbuf, uint32_t value)
{
  memcpy(bbuf, &value, sizeof(uint32_t));
}

uint32_t memread_u32(uint16_t addr)
{
  if (addr <= USER_VAR_END_ADDRESS_INCLUSIVE)
    return make_uint32(&bin_buf[addr]);
  if (is_pgv(addr))
    return DUMMY_DATA_REPLACE_ME;
  if (addr >= INTERAL_VAR_START_ADDRESS)
    return DUMMY_DATA_REPLACE_ME;
  return DUMMY_DATA_REPLACE_ME;
}

void memwrite_u32(uint16_t addr, uint32_t value)
{
  if (addr <= USER_VAR_END_ADDRESS_INCLUSIVE)
  {
    write_uint32_as_4B(&bin_buf[addr], value);
    return;
  }
  longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
}

uint8_t load_dsb(char* dsb_path, uint32_t* dsb_size)
{
  FILE *dsb_file = fopen(dsb_path, "rb");
  if(dsb_file == NULL)
    return EXE_DSB_FOPEN_FAIL;
  memset(bin_buf, 0, BIN_BUF_SIZE);
  *dsb_size = fread(bin_buf, 1, BIN_BUF_SIZE, dsb_file);
  fclose(dsb_file);
  if(*dsb_size == 0)
    return EXE_DSB_FREAD_ERROR;
  if(*dsb_size >= MAX_BIN_SIZE)
    return EXE_DSB_FILE_TOO_LARGE;
  if(bin_buf[0] != OP_VMVER)
    return EXE_DSB_INCOMPATIBLE_VERSION;
  if(bin_buf[1] != dsvm_version)
    return EXE_DSB_INCOMPATIBLE_VERSION;
  return EXE_OK;
}

uint8_t inst_size_lookup(uint8_t opcode)
{
  if(opcode == OP_VMVER)
    return 3;
  if(opcode >= OP_LEN_LOOKUP_SIZE || opcode_len_lookup[opcode] > MAX_INSTRUCTION_LEN)
    longjmp(jmpbuf, EXE_ILLEGAL_INSTRUCTION);
  return opcode_len_lookup[opcode];
}

void my_snprintf_int_only(char* buf, uint8_t buf_size,
                         uint32_t value,
                         uint8_t print_format,
                         uint8_t precision)
{
  if (buf == NULL || buf_size <= 2)
    return;

  memset(buf, 0, buf_size);

  if (precision == 0 && value == 0)
  {
    buf[0] = '0';
    return;
  }

  if(precision > 8)
    precision = 8;

  switch (print_format)
  {
    case STR_PRINT_FORMAT_DEC_UNSIGNED:
      snprintf(buf, buf_size, "%.*u", (int)precision, (unsigned int)value);
      break;

    case STR_PRINT_FORMAT_DEC_SIGNED:
      snprintf(buf, buf_size, "%.*d", (int)precision, (int)value);
      break;

    case STR_PRINT_FORMAT_HEX_LOWER_CASE:
      snprintf(buf, buf_size, "%.*x", (int)precision, (unsigned int)value);
      break;

    case STR_PRINT_FORMAT_HEX_UPPER_CASE:
      snprintf(buf, buf_size, "%.*X", (int)precision, (unsigned int)value);
      break;
  }
  buf[buf_size - 1] = '\0';
}

#define STR_BUF_SIZE 32
char make_str_buf[STR_BUF_SIZE];
#define READ_BUF_SIZE (256 * 5)
char read_buffer[READ_BUF_SIZE];

char* make_str(uint16_t str_start_addr, uint8_t kid)
{
  uint16_t curr_addr = str_start_addr;
  uint8_t this_char, lsb, msb;
  memset(read_buffer, 0, READ_BUF_SIZE);
  while(1)
  {
    this_char = read_byte(curr_addr);
    if(this_char == 0)
      break;

    if(this_char == MAKESTR_VAR_BOUNDARY_IMM)
    {
      curr_addr++;
      lsb = read_byte(curr_addr);
      curr_addr++;
      msb = read_byte(curr_addr);
      curr_addr++;
      curr_addr++;
      uint16_t var_addr = make_uint16(lsb, msb);
      uint32_t var_value = memread_u32(var_addr);
      memset(make_str_buf, 0, STR_BUF_SIZE);
      my_snprintf_int_only(make_str_buf, STR_BUF_SIZE, var_value, str_print_format, str_print_padding);
      strcat(read_buffer, make_str_buf);
      continue;
    }
    if(this_char == MAKESTR_VAR_BOUNDARY_REL)
    {
      curr_addr++;
      lsb = read_byte(curr_addr);
      curr_addr++;
      msb = read_byte(curr_addr);
      curr_addr++;
      curr_addr++;
      int16_t fp_offset = (int16_t)make_uint16(lsb, msb);
      uint32_t var_value;
      stack_read_fp_rel(&data_stack, fp_offset, &var_value);
      memset(make_str_buf, 0, STR_BUF_SIZE);
      my_snprintf_int_only(make_str_buf, STR_BUF_SIZE, var_value, str_print_format, str_print_padding);
      strcat(read_buffer, make_str_buf);
      continue;
    }
    memset(make_str_buf, 0, STR_BUF_SIZE);
    sprintf(make_str_buf, "%c", this_char);
    strcat(read_buffer, make_str_buf);
    curr_addr++;
  }
  return read_buffer;
}

void execute_instruction(uint16_t curr_pc, exe_context* exe)
{
  uint8_t opcode = read_byte(curr_pc);
  uint8_t instruction_size_bytes = inst_size_lookup(opcode);
  uint16_t payload = 0;
  exe->next_pc += instruction_size_bytes;

  
  if(instruction_size_bytes == 3)
    payload = make_uint16(read_byte(curr_pc+1), read_byte(curr_pc+2));
    
  if(PRINT_DEBUG)
  {
    printf("\n--------------------\n");
    printf("PC: %04d    Opcode: %02d    Payload: %04x", curr_pc, opcode, payload);
    printf("\n");
  }

  if(opcode == OP_NOP || opcode == OP_VMVER)
  {
    return;
  }
  else if(opcode == OP_PUSHC16)
  {
    stack_push(&data_stack, payload);
    stack_print(&data_stack, "AFTER PUSHC16");
  }
  else if(opcode == OP_PUSHI)
  {
    stack_push(&data_stack, memread_u32(payload));
    stack_print(&data_stack, "AFTER PUSHI");
  }
  else if(opcode == OP_PUSHR)
  {
    uint32_t this_value;
    stack_read_fp_rel(&data_stack, (int16_t)payload, &this_value);
    stack_push(&data_stack, this_value);
    stack_print(&data_stack, "AFTER PUSHR");
  }
  else if(opcode == OP_POPI)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    memwrite_u32(payload, this_value);
    stack_print(&data_stack, "AFTER POPI");
  }
  else if(opcode == OP_POPR)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    stack_write_fp_rel(&data_stack, (int16_t)payload, this_value);
    stack_print(&data_stack, "AFTER POPR");
  }
  else if(opcode == OP_BRZ)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    if(this_value == 0)
      exe->next_pc = payload;
  }
  else if(opcode == OP_JMP)
  {
    exe->next_pc = payload;
  }
  else if(opcode == OP_ALLOC)
  {
    for (size_t i = 0; i < payload; i++)
      stack_push(&data_stack, 0);
    stack_print(&data_stack, "After ALLOC");
  }
  else if(opcode == OP_CALL)
  {
    uint32_t frame_info = (data_stack.fp << 16) | (curr_pc + instruction_size_bytes);
    stack_push(&data_stack, frame_info);
    data_stack.fp = data_stack.sp + sizeof(uint32_t);
    stack_print(&data_stack, "CALL");
    exe->next_pc = payload;
  }
  else if(opcode == OP_RET)
  {
    stack_print(&data_stack, "RET");
    uint32_t func_return_val;
    // stash return value
    stack_pop(&data_stack, &func_return_val);
    // pop until frame_info is on TOS
    while(1)
    {
      if(data_stack.sp + sizeof(uint32_t) == data_stack.fp)
        break;
      stack_pop(&data_stack, NULL);
    }
    // pop frame_info and restore PC and FP
    uint32_t frame_info;
    stack_pop(&data_stack, &frame_info);
    data_stack.fp = (frame_info >> 16) & 0xffff;
    exe->next_pc = frame_info & 0xffff;
    // pop off arguments
    for (size_t i = 0; i < payload; i++)
      stack_pop(&data_stack, NULL);
    // push return value back on stack
    stack_push(&data_stack, func_return_val);
    stack_print(&data_stack, "UNWIND DONE");
  }
  else if(opcode == OP_HALT)
  {
    exe->result = EXE_HALT;
  }
  else if(opcode == OP_EQ)
  {
    binop(binop_equal);
  }
  else if(opcode == OP_NOTEQ)
  {
    binop(binop_not_equal);
  }
  else if(opcode == OP_LT)
  {
    binop(binop_lower);
  }
  else if(opcode == OP_LTE)
  {
    binop(binop_lower_eq);
  }
  else if(opcode == OP_GT)
  {
    binop(binop_greater);
  }
  else if(opcode == OP_GTE)
  {
    binop(binop_greater_eq);
  }
  else if(opcode == OP_ADD)
  {
    binop(binop_add);
  }
  else if(opcode == OP_SUB)
  {
    binop(binop_sub);
  }
  else if(opcode == OP_MULT)
  {
    binop(binop_mul);
  }
  else if(opcode == OP_DIV)
  {
    binop(binop_divide);
  }
  else if(opcode == OP_MOD)
  {
    binop(binop_mod);
  }
  else if(opcode == OP_POW)
  {
    binop(binop_power);
  }
  else if(opcode == OP_LSHIFT)
  {
    binop(binop_lshift);
  }
  else if(opcode == OP_RSHIFT)
  {
    binop(binop_rshift);
  }
  else if(opcode == OP_BITOR)
  {
    binop(binop_bitwise_or);
  }
  else if(opcode == OP_BITXOR)
  {
    binop(binop_bitwise_xor);
  }
  else if(opcode == OP_BITAND)
  {
    binop(binop_bitwise_and);
  }
  else if(opcode == OP_LOGIAND)
  {
    binop(binop_logical_and);
  }
  else if(opcode == OP_LOGIOR)
  {
    binop(binop_logical_or);
  }
  else if(opcode == OP_BITINV)
  {
    unaryop(unaop_bit_inv);
  }
  else if(opcode == OP_LOGINOT)
  {
    unaryop(unaop_logical_not);
  }
  else if(opcode == OP_USUB)
  {
    unaryop(unaop_usub);
  }  
  else if(opcode == OP_STR)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    char* str_buf = make_str((uint16_t)this_value, this_key_id);
    printf(">>>>> STRING: %s\n", str_buf);
  }
  else if(opcode == OP_STRLN)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    char* str_buf = make_str((uint16_t)this_value, this_key_id);
    printf(">>>>> STRINGLN: %s\n", str_buf);
  }
  else
  {
    printf("Unimplemented opcode: %d\n", opcode);longjmp(jmpbuf, EXE_ILLEGAL_INSTRUCTION);
  }
}

void run_dsb(exe_context* er, char* dsb_path)
{
  uint32_t this_dsb_size = 0;
  uint8_t dsb_load_result = load_dsb(dsb_path, &this_dsb_size);
  if(dsb_load_result)
  {
    printf("DSB load fail: %d\n", dsb_load_result);
    er->result = dsb_load_result;
    return;
  }

  uint16_t current_pc = 0;
  uint16_t data_stack_size_bytes = STACK_BASE_ADDR - this_dsb_size - STACK_MOAT_BYTES;
  printf("DSB size: %d Bytes\n", this_dsb_size);
  printf("Stack size: %d Bytes\n", data_stack_size_bytes);
  stack_init(&data_stack, bin_buf, STACK_BASE_ADDR, data_stack_size_bytes);

  int panic_code = setjmp(jmpbuf);
  if(panic_code != 0)
  {
    printf("VM Crashed! Panic: %d\n", panic_code);
    return;
  }
  
  while(1)
  {
    execute_instruction(current_pc, er);
    current_pc = er->next_pc;
    if(er->result != EXE_OK)
      break;
    if(current_pc > this_dsb_size)
      break;
  }
  printf("Execution Completed\n");
}

exe_context execon;

int main()
{
  run_dsb(&execon, "../ds2py/out.dsb");
  return 0;
}