diff --git a/ds2py/myast.py b/ds2py/myast.py
index fcceeb4..9a3305b 100644
--- a/ds2py/myast.py
+++ b/ds2py/myast.py
@@ -27,15 +27,15 @@ def get_orig_ds_lnumsf1_from_py_lnumsf1(rdict, this_pylnum_sf1):
     return og_index_sf1
 
 def print_node_info(node):
-	lineno = getattr(node, "lineno", None)
-	print(f"---Line {lineno}: {type(node)}---")
-	for item in node._fields:
-		if getattr(node, item, None) is not None:
-			print(f"{item}: {getattr(node, item, None)}")
-	print()
+    lineno = getattr(node, "lineno", None)
+    print(f"---Line {lineno}: {type(node)}---")
+    for item in node._fields:
+        if getattr(node, item, None) is not None:
+            print(f"{item}: {getattr(node, item, None)}")
+    print()
 
 AST_LEAF_NODES = (
-	ast.Name,
+    ast.Name,
 )
 
 class add_nop:
@@ -51,96 +51,96 @@ class add_push0:
         self.label = label
 
 def is_leaf(node):
-	if isinstance(node, AST_LEAF_NODES):
-		return True
-	return not any(ast.iter_child_nodes(node))
+    if isinstance(node, AST_LEAF_NODES):
+        return True
+    return not any(ast.iter_child_nodes(node))
 
 def postorder_walk(node, action, goodies):
-	this_pylnum_sf1 = getattr(node, "lineno", None)
-	this_orig_ds_lnum_sf1 = get_orig_ds_lnumsf1_from_py_lnumsf1(goodies, this_pylnum_sf1)
-	if isinstance(node, ast.Expr):
-		postorder_walk(node.value, action, goodies)
-	elif isinstance(node, ast.BinOp):
-		postorder_walk(node.left, action, goodies)
-		postorder_walk(node.right, action, goodies)
-		postorder_walk(node.op, action, goodies)
-	elif isinstance(node, ast.BoolOp):
-		# Consecutive operations with the same operator, such as a or b or c, are collapsed into one node with several values.
-		if len(node.values) > 2:
-			raise ValueError("Ambiguous expr, add parentheses.")
-		for item in node.values:
-			postorder_walk(item, action, goodies)
-		postorder_walk(node.op, action, goodies)
-	elif isinstance(node, ast.UnaryOp):
-		postorder_walk(node.operand, action, goodies)
-		postorder_walk(node.op, action, goodies)
-	elif isinstance(node, ast.Compare):
-		if len(node.comparators) > 1 or len(node.ops) > 1:
-			raise ValueError("Multiple Comparators")
-		postorder_walk(node.left, action, goodies)
-		postorder_walk(node.comparators[0], action, goodies)
-		postorder_walk(node.ops[0], action, goodies)
-	elif isinstance(node, ast.Assign):
-		postorder_walk(node.value, action, goodies)
-		if len(node.targets) != 1:
-			raise ValueError("Multiple Assignments")
-		postorder_walk(node.targets[0], action, goodies)
-	elif isinstance(node, ast.FunctionDef):
-		this_func_label = f"func_{node.name}"
-		goodies['this_func_name'] = node.name
-		action(add_nop(this_func_label), goodies)
-		for item in node.body:
-			postorder_walk(item, action, goodies)
-	elif isinstance(node, ast.Return):
-		if node.value is None:
-			action(add_push0(), goodies)
-		else:
-			postorder_walk(node.value, action, goodies)
-		action(node, goodies)
-	elif isinstance(node, ast.AugAssign):
-		raise ValueError(f"{node.__class__.__name__}: To Be Implemented")
-	elif isinstance(node, ast.If):
-		if_skip_label = f"{node.__class__.__name__}_skip@{this_orig_ds_lnum_sf1}"
-		if_end_label = f"{node.__class__.__name__}_end@{this_orig_ds_lnum_sf1}"
-		if len(node.orelse) == 0:
-			if_skip_label = if_end_label
-		goodies['if_destination_label'] = if_skip_label
-		postorder_walk(node.test, action, goodies)
-		action(node, goodies)
-		for item in node.body:
-			postorder_walk(item, action, goodies)
-		if len(node.orelse):
-			action(add_jmp(if_end_label), goodies)
-			action(add_nop(if_skip_label), goodies)
-			for item in node.orelse:
-				postorder_walk(item, action, goodies)
-		action(add_nop(if_end_label), goodies)
-	elif isinstance(node, ast.While):
-		while_start_label = f"{node.__class__.__name__}_start@{this_orig_ds_lnum_sf1}"
-		while_end_label = f"{node.__class__.__name__}_end@{this_orig_ds_lnum_sf1}"
-		action(add_nop(while_start_label), goodies)
-		postorder_walk(node.test, action, goodies)
-		goodies['while_start_label'] = while_start_label
-		goodies['while_end_label'] = while_end_label
-		action(node, goodies)
-		for item in node.body:
-			postorder_walk(item, action, goodies)
-		action(add_jmp(while_start_label), goodies)
-		action(add_nop(while_end_label), goodies)
-	elif isinstance(node, ast.Call):
-		print_node_info(node)
-		func_name = node.func.id
-		callee_arg_count = len(node.args)
-		func_arg_count = how_many_args(func_name, goodies['symtable_root'])
-		# is_builtin_func(name) do it here
-		if func_arg_count is None:
-			raise ValueError(f"Function {func_name}() not found")
-		if callee_arg_count != func_arg_count:
-			raise ValueError("Wrong number of arguments")
-		for item in node.args:
-			postorder_walk(item, action, goodies)
-		action(node, goodies)
-	elif is_leaf(node):
-		action(node, goodies)
-	else:
-		raise ValueError(f"Unknown AST Node: {node}")
+    this_pylnum_sf1 = getattr(node, "lineno", None)
+    this_orig_ds_lnum_sf1 = get_orig_ds_lnumsf1_from_py_lnumsf1(goodies, this_pylnum_sf1)
+    if isinstance(node, ast.Expr):
+        postorder_walk(node.value, action, goodies)
+    elif isinstance(node, ast.BinOp):
+        postorder_walk(node.left, action, goodies)
+        postorder_walk(node.right, action, goodies)
+        postorder_walk(node.op, action, goodies)
+    elif isinstance(node, ast.BoolOp):
+        # Consecutive operations with the same operator, such as a or b or c, are collapsed into one node with several values.
+        if len(node.values) > 2:
+            raise ValueError("Ambiguous expr, add parentheses.")
+        for item in node.values:
+            postorder_walk(item, action, goodies)
+        postorder_walk(node.op, action, goodies)
+    elif isinstance(node, ast.UnaryOp):
+        postorder_walk(node.operand, action, goodies)
+        postorder_walk(node.op, action, goodies)
+    elif isinstance(node, ast.Compare):
+        if len(node.comparators) > 1 or len(node.ops) > 1:
+            raise ValueError("Multiple Comparators")
+        postorder_walk(node.left, action, goodies)
+        postorder_walk(node.comparators[0], action, goodies)
+        postorder_walk(node.ops[0], action, goodies)
+    elif isinstance(node, ast.Assign):
+        postorder_walk(node.value, action, goodies)
+        if len(node.targets) != 1:
+            raise ValueError("Multiple Assignments")
+        postorder_walk(node.targets[0], action, goodies)
+    elif isinstance(node, ast.FunctionDef):
+        this_func_label = f"func_{node.name}"
+        goodies['this_func_name'] = node.name
+        action(add_nop(this_func_label), goodies)
+        for item in node.body:
+            postorder_walk(item, action, goodies)
+    elif isinstance(node, ast.Return):
+        if node.value is None:
+            action(add_push0(), goodies)
+        else:
+            postorder_walk(node.value, action, goodies)
+        action(node, goodies)
+    elif isinstance(node, ast.AugAssign):
+        raise ValueError(f"{node.__class__.__name__}: To Be Implemented")
+    elif isinstance(node, ast.If):
+        if_skip_label = f"{node.__class__.__name__}_skip@{this_orig_ds_lnum_sf1}"
+        if_end_label = f"{node.__class__.__name__}_end@{this_orig_ds_lnum_sf1}"
+        if len(node.orelse) == 0:
+            if_skip_label = if_end_label
+        goodies['if_destination_label'] = if_skip_label
+        postorder_walk(node.test, action, goodies)
+        action(node, goodies)
+        for item in node.body:
+            postorder_walk(item, action, goodies)
+        if len(node.orelse):
+            action(add_jmp(if_end_label), goodies)
+            action(add_nop(if_skip_label), goodies)
+            for item in node.orelse:
+                postorder_walk(item, action, goodies)
+        action(add_nop(if_end_label), goodies)
+    elif isinstance(node, ast.While):
+        while_start_label = f"{node.__class__.__name__}_start@{this_orig_ds_lnum_sf1}"
+        while_end_label = f"{node.__class__.__name__}_end@{this_orig_ds_lnum_sf1}"
+        action(add_nop(while_start_label), goodies)
+        postorder_walk(node.test, action, goodies)
+        goodies['while_start_label'] = while_start_label
+        goodies['while_end_label'] = while_end_label
+        action(node, goodies)
+        for item in node.body:
+            postorder_walk(item, action, goodies)
+        action(add_jmp(while_start_label), goodies)
+        action(add_nop(while_end_label), goodies)
+    elif isinstance(node, ast.Call):
+        print_node_info(node)
+        func_name = node.func.id
+        callee_arg_count = len(node.args)
+        func_arg_count = how_many_args(func_name, goodies['symtable_root'])
+        # is_builtin_func(name) do it here
+        if func_arg_count is None:
+            raise ValueError(f"Function {func_name}() not found")
+        if callee_arg_count != func_arg_count:
+            raise ValueError("Wrong number of arguments")
+        for item in node.args:
+            postorder_walk(item, action, goodies)
+        action(node, goodies)
+    elif is_leaf(node):
+        action(node, goodies)
+    else:
+        raise ValueError(f"Unknown AST Node: {node}")
