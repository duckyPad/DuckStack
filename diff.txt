diff --git a/ds2py/make_bytecode.py b/ds2py/make_bytecode.py
index e00e7c6..8e11c6b 100644
--- a/ds2py/make_bytecode.py
+++ b/ds2py/make_bytecode.py
@@ -47,7 +47,7 @@ OP_RET = ("RET", 9)
 OP_HALT = ("HALT", 10)
 # to be resolved into PUSHI32 or PUSHR32 depending on variable type
 OP_PUSH32_DUMMY = ("PUSHD32", 11)
-OP_POP32_DUMMY = ("PUSHD32", 12)
+OP_POP32_DUMMY = ("POPD32", 12)
 
 # Binary Operators
 OP_EQ = ("EQ", 32)
@@ -199,7 +199,12 @@ AST_ARITH_NODES = (
 def visit_node(node, goodies):
     instruction_list = goodies['assembly_list']
     print("at leaf:", node)
-    if isinstance(node, ast.Name):
+    if isinstance(node, ast.Name) and isinstance(node.ctx, ast.Store):
+        this_instruction = get_empty_instruction()
+        this_instruction['opcode'] = OP_POP32_DUMMY
+        this_instruction['oparg'] = str(node.id)
+        instruction_list.append(this_instruction)
+    elif isinstance(node, ast.Name) and isinstance(node.ctx, ast.Load):
         this_instruction = get_empty_instruction()
         this_instruction['opcode'] = OP_PUSH32_DUMMY
         this_instruction['oparg'] = str(node.id)
@@ -248,7 +253,7 @@ pyout = ds2py.run_all(post_pp_listing)
 save_lines_to_file(pyout, "pyds.py")
 source = dsline_to_source(pyout)
 tree = ast.parse(source, mode="exec", optimize=-1)
-# print(ast.dump(tree, indent=2))
+print(ast.dump(tree, indent=2))
 
 rdict["assembly_list"] = []
 rdict["func_assembly_dict"] = {}
diff --git a/ds2py/myast.py b/ds2py/myast.py
index 3d4259a..613b163 100644
--- a/ds2py/myast.py
+++ b/ds2py/myast.py
@@ -45,6 +45,10 @@ def postorder_walk(node, action, goodies):
 		postorder_walk(node.targets[0], action, goodies)
 	elif isinstance(node, ast.FunctionDef):
 		raise ValueError("FunctionDef Node: Not Implemented")
+	elif isinstance(node, ast.If):
+		# print_node_info(node)
+		postorder_walk(node.test, action, goodies)
+		# exit()
 	elif is_leaf(node):
 		action(node, goodies)
 	else:
diff --git a/ds2py/ppds.txt b/ds2py/ppds.txt
index 1de89d3..6aff1df 100644
--- a/ds2py/ppds.txt
+++ b/ds2py/ppds.txt
@@ -1,11 +1,5 @@
-foo = 0
-bar = 0
-IF foo > 5 THEN
-    bar = 1
-ELSE IF foo > 6 THEN
-    bar = 2
-ELSE IF foo > 7 THEN
-    bar = 3
-ELSE
-    bar = 4
+VAR $foo = 3
+VAR $bar = 4
+IF $foo > 5 THEN
+    $bar = 6
 END_IF
diff --git a/ds2py/pyds.py b/ds2py/pyds.py
index ec40883..5483f22 100644
--- a/ds2py/pyds.py
+++ b/ds2py/pyds.py
@@ -1,10 +1,4 @@
-foo = 0
-bar = 0
+foo = 3
+bar = 4
 if foo > 5:
-    bar = 1
-elif foo > 6:
-    bar = 2
-elif foo > 7:
-    bar = 3
-else:
-    bar = 4
+    bar = 6
diff --git a/ds2py/sample_scripts/test.txt b/ds2py/sample_scripts/test.txt
index 1d6112b..ff5de69 100644
--- a/ds2py/sample_scripts/test.txt
+++ b/ds2py/sample_scripts/test.txt
@@ -1,13 +1,7 @@
-foo = 0
-bar = 0
+VAR $foo = 3
+VAR $bar = 4
 
-IF foo > 5 THEN
-bar = 1
-ELSE IF foo > 6 THEN
-bar = 2
-ELSE IF foo > 7 THEN
-bar = 3
-ELSE
-bar = 4
+IF $foo > 5 THEN
+$bar = 6
 END_IF
 
diff --git a/src/_scrap.py b/src/_scrap.py
deleted file mode 100644
index c4dbd58..0000000
--- a/src/_scrap.py
+++ /dev/null
@@ -1,35 +0,0 @@
-elif isinstance(node, ast.Call):
-        fun_name = node.func.id
-        if fun_name not in func_lookup:
-            raise ValueError("unknown function name")
-        this_instruction = get_empty_instruction()
-        this_instruction['opcode'] = OP_CALL
-        this_instruction['oparg'] = label_dict[func_lookup[fun_name]['fun_start']]
-        instruction_list.append(this_instruction)
-
-
-        elif first_word == cmd_RETURN:
-            inst_list = parse_return_value(this_line, cmd_RETURN)
-            for item in inst_list:
-                print(item)
-            exit()
-
-            # inst_list = parse_multi_expression(1, this_line)
-            # print(inst_list)
-            # exit()
-            # this_instruction['opcode'] = OP_RET
-            # assembly_listing.append(this_instruction)
-
-
-elif first_word == cmd_END_FUNCTION:
-            # RET, then NOP
-            inst_list = parse_multi_expression(1, this_line)
-            print(inst_list)
-            exit()
-            this_instruction['opcode'] = OP_RET
-            this_instruction['comment'] = None
-            assembly_listing.append(this_instruction)
-            this_instruction = get_empty_instruction()
-            this_instruction['comment'] = this_line
-            this_instruction['label'] = label_dict[lnum]
-            assembly_listing.append(this_instruction)
\ No newline at end of file
diff --git a/src/ds3_preprocessor.py b/src/ds3_preprocessor.py
index 51a020c..07e2be1 100644
--- a/src/ds3_preprocessor.py
+++ b/src/ds3_preprocessor.py
@@ -16,7 +16,7 @@ def get_default_var_table():
 
 # name : value
 var_table = get_default_var_table()
-# name :  {"fun_start":int, 'fun_end':int}
+# name : (start line number, end line number)
 func_table = {}
 if_take_table = {}
 if_skip_table = {}
@@ -75,8 +75,38 @@ def contains_english_alphabet(in_str):
     return False
 
 def check_rvalue(rvalue_str, vt):
+    if len(rvalue_str) == 0:
+        return False, "empty rvalue"
+    # print("rvalue_str before replacement:", rvalue_str)
+    var_list = sorted(list(vt.keys()), key=len, reverse=True)
+    for key in var_list:
+        if "$"+key in rvalue_str:
+            rvalue_str = rvalue_str.replace("$"+key, str(vt[key])).strip()
+    # print("rvalue_str after replacement:", rvalue_str)
+
+    # if contains_english_alphabet(rvalue_str):
+    #     return False, "unknown variable or invalid character"
+    try:
+        rvalue_str = rvalue_str.replace("||", " or ").replace("&&", " and ")
+        # print("rvalue_str after replacement:", rvalue_str)
+        eval(rvalue_str)
+    except Exception as e:
+        return False, f"expr eval fail: {e}"
     return True, ''
 
+def is_valid_expr(whole_line, vt):
+    presult = PARSE_ERROR
+    pcomment = 'Invalid expression'
+    try:
+        whole_line = whole_line.split(' ', 1)[1]
+        is_valid_rv, rv_comment = check_rvalue(whole_line, vt)
+        if is_valid_rv:
+            presult = PARSE_OK
+            return presult, pcomment
+    except Exception as e:
+        pass
+    return presult, pcomment
+
 def assign_var(var_keyword, pgm_line, vt, check_duplicate=False):
     has_global_variable = False
     try:
@@ -126,30 +156,19 @@ def new_string_block_check(pgm_line, lnum, sbss, sbdict):
 def new_func_check(pgm_line, lnum, fss, fdict):
     if len(fss) != 0:
         return PARSE_ERROR, "unmatched END_FUNCTION"
-    if pgm_line.endswith(")") is False:
-        return PARSE_ERROR, "missing )"
+    if pgm_line.endswith("()") is False:
+        return PARSE_ERROR, "invalid declaration"
     try:
-        fun_name = pgm_line.split()[1].split('(')[0]
+        fun_name = pgm_line.split()[1].split('()')[0]
     except Exception:
-        return PARSE_ERROR, "invalid func name"
+        return PARSE_ERROR, "invalid declaration"
     if_valid_vn, vn_comment = is_valid_var_name(fun_name)
     if if_valid_vn is False:
         return PARSE_ERROR, vn_comment
     if fun_name in fdict:
         return PARSE_ERROR, "function already exists"
-    try:
-        all_args = pgm_line.split("(", 1)[-1].rsplit(")", 1)[0]
-        arg_list = [f"{FUNC_NAME_MANGLE_PREFIX}{fun_name}_{x.strip()}" for x in all_args.split(",")]
-    except Exception:
-        return PARSE_ERROR, "Arg parse error"
-    for arg in arg_list:
-        is_valid, vn_comment = is_valid_var_name(arg)
-        if is_valid is False:
-            return PARSE_ERROR, vn_comment
-    if len(arg_list) != len(set(arg_list)):
-        return PARSE_ERROR, "Duplicate arg name"
     fss.append(fun_name)
-    fdict[fun_name] = {"fun_start":lnum, 'fun_end':None, 'args':arg_list}
+    fdict[fun_name] = {"fun_start":lnum, 'fun_end':None}
     return PARSE_OK, ''
 
 def rem_block_end_check(pgm_line, lnum, rbss, rbdict):
@@ -359,6 +378,18 @@ def ensure_zero_arg(pgm_line):
 def needs_rstrip(first_word):
     return not (first_word.startswith(cmd_STRING) or first_word == cmd_OLED_PRINT)
 
+def check_first_arg(pgm_line, vt, allow_multi_arg=False):
+    split = [x for x in pgm_line.split(' ') if len(x) > 0]
+    if allow_multi_arg is False and len(split) != 2:
+        return PARSE_ERROR, "only one argument allowed"
+    try:
+        if int(split[1]) < 0:
+            return PARSE_ERROR, "value can't be negative"
+        return PARSE_OK, ""
+    except:
+        pass
+    return is_valid_expr(pgm_line, vt)
+
 def check_loop(pgm_line):
     try:
         line_split = [x for x in pgm_line.split(cmd_LOOP) if len(x) > 0]
@@ -499,7 +530,7 @@ def run_once(program_listing):
             presult, pcomment = new_stringln_block_check(this_line, line_number_starting_from_1, strlen_block_search_stack, strlen_block_table)
         elif first_word == cmd_STRING_BLOCK:
             presult, pcomment = new_string_block_check(this_line, line_number_starting_from_1, str_block_search_stack, str_block_table)
-        elif first_word == cmd_RETURN:
+        elif this_line == cmd_RETURN:
             if len(func_search_stack) == 0:
                 presult = PARSE_ERROR
                 pcomment = f"RETURN outside function"
@@ -507,9 +538,9 @@ def run_once(program_listing):
                 presult = PARSE_OK
                 pcomment = ''
         elif first_word == cmd_DELAY:
-            presult, pcomment = PARSE_OK, ''
+            presult, pcomment = check_first_arg(this_line, var_table, allow_multi_arg=True)
         elif first_word == cmd_GOTO_PROFILE:
-            presult, pcomment = PARSE_OK, ''
+            presult, pcomment = check_first_arg(this_line, var_table, allow_multi_arg=True)
         elif first_word == cmd_SWCC:
             return_dict['color_state_save_needed'] = True
             presult, pcomment = PARSE_OK, ''
@@ -553,9 +584,12 @@ def run_once(program_listing):
         elif first_word in [cmd_STRING, cmd_STRINGLN, cmd_OLED_PRINT]:
             presult = PARSE_OK
             pcomment = ''
-        # elif this_line.endswith("()"):
-        elif is_func_call(this_line, func_table):
-            presult, pcomment = PARSE_OK, ''
+        elif this_line.endswith("()"):
+            fun_name = this_line[0:len(this_line)-2]
+            if fun_name in func_table:
+                presult = PARSE_OK
+            else:
+                pcomment = f"Unknown function"
         else:
             presult, pcomment = ds_syntax_check.parse_line(this_line)
         
diff --git a/src/duckypad_config.py b/src/duckypad_config.py
index 5ff6cd6..da83479 100644
--- a/src/duckypad_config.py
+++ b/src/duckypad_config.py
@@ -176,21 +176,14 @@ Added Bitwise XOR support
     XOR is ^
     Power-of is now **
 Added RTC Sync
-
-3.5.0
-2025 11 23
-DSVM Version 2
-32 Bit Support
-Flat memory map
-adjusted base addresses for working memory
 """
 
-THIS_VERSION_NUMBER = '3.5.0'
+THIS_VERSION_NUMBER = '3.4.0'
 
 THIS_DUCKYPAD = dp_type()
 
-MIN_DUCKYPAD_PRO_FIRMWARE_VERSION = "2.6.0"
-MAX_DUCKYPAD_PRO_FIRMWARE_VERSION = "2.9.0"
+MIN_DUCKYPAD_PRO_FIRMWARE_VERSION = "2.0.0"
+MAX_DUCKYPAD_PRO_FIRMWARE_VERSION = "2.5.0"
 MIN_DUCKYPAD_2020_FIRMWARE_VERSION = "2.0.0"
 MAX_DUCKYPAD_2020_FIRMWARE_VERSION = "2.5.0"
 
diff --git a/src/make_bytecode.py b/src/make_bytecode.py
index 180b1ce..16462a9 100644
--- a/src/make_bytecode.py
+++ b/src/make_bytecode.py
@@ -16,20 +16,15 @@ Done:
 Added VMVER to aid version checking
 mouse move and mouse scroll arguments on stack
 more changes at the end of bytecode_vm.md
-
-Version 2:
-2025-11-23
-New flat memory map
-
 """
 
-DS_VM_VERSION = 2
+DS_VM_VERSION = 1
 
 # CPU instructions
 OP_NOP = ("NOP", 0)
-OP_PUSHC16 = ("PUSHC16", 1)
-OP_PUSHI32 = ("PUSHI32", 2)
-OP_POP32 = ("POP32", 3)
+OP_PUSHC = ("PUSHC", 1)
+OP_PUSHI = ("PUSHI", 2)
+OP_POP = ("POP", 3)
 OP_BRZ = ("BRZ", 4)
 OP_JMP = ("JMP", 5)
 OP_CALL = ("CALL", 6)
@@ -119,12 +114,12 @@ arith_lookup = {
 zero = 0
 endianness = 'little'
 var_boundary = 0x1f
+INSTRUCTION_SIZE_BYTES = 3
 
 if_skip_table = None
 if_info_list = None
 while_lookup = None
-user_var_lookup = None
-func_arg_order_lookup = None
+var_lookup = None
 compact_program_listing = None
 label_dict = None
 func_lookup = None
@@ -167,41 +162,19 @@ def print_asslist(lll):
         print_instruction(item)
     print()
 
-def make_instruction_pushc32(value):
-    node_value_high = (int(value) & 0xffff0000) >> 16
-    node_value_low = int(value) & 0xffff
-    inst_list = []
-    this_instruction = get_empty_instruction()
-    this_instruction['opcode'] = OP_PUSHC16
-    this_instruction['oparg'] = node_value_low
-    inst_list.append(this_instruction)
-    if node_value_high:
-        this_instruction = get_empty_instruction()
-        this_instruction['opcode'] = OP_PUSHC16
-        this_instruction['oparg'] = node_value_high
-        inst_list.append(this_instruction)
-        this_instruction = get_empty_instruction()
-        this_instruction['opcode'] = OP_PUSHC16
-        this_instruction['oparg'] = 16
-        inst_list.append(this_instruction)
-        this_instruction = get_empty_instruction()
-        this_instruction['opcode'] = OP_LSHIFT
-        inst_list.append(this_instruction)
-        this_instruction = get_empty_instruction()
-        this_instruction['opcode'] = OP_BITOR
-        inst_list.append(this_instruction)
-    return inst_list
-
 def visit_node(node, instruction_list):
     # print(node.__dict__)
     # a node can be Name, Constant, and operations such as ADD, SUB, COMPARE, etc
     if isinstance(node, ast.Name):
         this_instruction = get_empty_instruction()
-        this_instruction['opcode'] = OP_PUSHI32
+        this_instruction['opcode'] = OP_PUSHI
         this_instruction['oparg'] = str(node.id)
         instruction_list.append(this_instruction)
     elif isinstance(node, ast.Constant):
-        instruction_list += make_instruction_pushc32(node.value)
+        this_instruction = get_empty_instruction()
+        this_instruction['opcode'] = OP_PUSHC
+        this_instruction['oparg'] = int(node.value) & 0xffff
+        instruction_list.append(this_instruction)
     elif isinstance(node, ast.Compare):
         op_name = node.ops[0].__class__.__name__
         if op_name not in arith_lookup:
@@ -229,16 +202,6 @@ def visit_node(node, instruction_list):
         this_instruction = get_empty_instruction()
         this_instruction['opcode'] = OP_MULT
         instruction_list.append(this_instruction)
-    elif isinstance(node, ast.Call):
-        fun_name = node.func.id
-        if fun_name not in func_lookup:
-            raise ValueError("unknown function name")
-        if len(node.args) != len(func_lookup[fun_name]['args']):
-            raise ValueError("Wrong number of arguments")
-        this_instruction = get_empty_instruction()
-        this_instruction['opcode'] = OP_CALL
-        this_instruction['oparg'] = label_dict[func_lookup[fun_name]['fun_start']]
-        instruction_list.append(this_instruction)
     else:
         raise ValueError("Unimplemented AST operation")
 
@@ -253,10 +216,13 @@ def evaluate_expr(expr):
     if myast.is_walkable(root):
         myast.postorder_walk(root, visit_node, instruction_list, expr)
     elif isinstance(root, ast.Constant):
-        instruction_list += make_instruction_pushc32(root.value)
+        this_instruction = get_empty_instruction()
+        this_instruction['opcode'] = OP_PUSHC
+        this_instruction['oparg'] = root.value
+        instruction_list.append(this_instruction)
     elif isinstance(root, ast.Name):
         this_instruction = get_empty_instruction()
-        this_instruction['opcode'] = OP_PUSHI32
+        this_instruction['opcode'] = OP_PUSHI
         this_instruction['oparg'] = str(root.id)
         instruction_list.append(this_instruction)
     else:
@@ -273,7 +239,7 @@ def assign_var(var_keyword, pgm_line):
     rvalue = replace_operators(rvalue)
     ins_list = evaluate_expr(rvalue)
     this_instruction = get_empty_instruction()
-    this_instruction['opcode'] = OP_POP32
+    this_instruction['opcode'] = OP_POP
     this_instruction['oparg'] = lvalue
     ins_list.append(this_instruction)
     for item in ins_list:
@@ -346,16 +312,6 @@ def make_delay_instruction(comment):
     this_instruction['comment'] = comment
     return this_instruction
 
-def parse_return_value(whole_line, ret_cmd):
-    return_arg = whole_line[len(ret_cmd):].strip()
-    if len(return_arg) == 0:
-        this_instruction = get_empty_instruction()
-        this_instruction['opcode'] = OP_PUSHC16
-        this_instruction['oparg'] = 0
-        this_instruction['comment'] = whole_line
-        return [this_instruction]
-    return parse_exp_one_item(return_arg, whole_line)
-
 def parse_exp_one_item(token, pgm_line):
     expression = replace_operators(token)
     ins_list = evaluate_expr(expression)
@@ -417,7 +373,7 @@ def replace_var_in_str(msg, vad):
 
 def push_1_constant_on_stack(value, comment=None):
     this_instruction = get_empty_instruction()
-    this_instruction['opcode'] = OP_PUSHC16
+    this_instruction['opcode'] = OP_PUSHC
     this_instruction['oparg'] = value & 0xffff
     if comment is not None:
         this_instruction['comment'] = comment
@@ -434,14 +390,13 @@ def make_dsb_with_exception(program_listing, profile_list=None):
     global if_skip_table
     global if_info_list
     global while_lookup
-    global user_var_lookup
+    global var_lookup
     global compact_program_listing
     global label_dict
     global func_lookup
     global str_lookup
     global current_line_content
     global current_line_number_sf1
-    global func_arg_order_lookup
 
     current_line_number_sf1 = 0
     current_line_content = ''
@@ -458,23 +413,13 @@ def make_dsb_with_exception(program_listing, profile_list=None):
     if_skip_table = result_dict['if_skip_table']
     if_info_list = result_dict["if_info"]
     while_lookup = result_dict['while_table_bidirectional']
-    user_var_lookup = result_dict['var_table']
+    var_lookup = result_dict['var_table']
     compact_program_listing = result_dict['compact_listing']
     label_dict = {}
     func_lookup = result_dict['func_table']
     str_lookup = {}
     break_dict = result_dict['break_dict']
     continue_dict = result_dict['continue_dict']
-    func_arg_order_lookup = {}
-
-    for fun_name in func_lookup:
-        arg_list = func_lookup[fun_name]['args']
-        if arg_list is None or len(arg_list) == 0:
-            continue
-        for index, this_arg in enumerate(arg_list):
-            if this_arg in func_arg_order_lookup:
-                raise ValueError("Duplicate function arguments")
-            func_arg_order_lookup[this_arg] = index
 
     print("--------- Program Listing After Preprocessing: ---------")
 
@@ -487,7 +432,7 @@ def make_dsb_with_exception(program_listing, profile_list=None):
 
     first_instruction = get_empty_instruction()
     first_instruction['opcode'] = OP_VMINFO
-    first_instruction['oparg'] = DS_VM_VERSION & 0xff
+    first_instruction['oparg'] = ((DS_VM_VERSION % 0xf) << 8)
     assembly_listing.append(first_instruction)
 
     for line_obj in compact_program_listing:
@@ -533,7 +478,7 @@ def make_dsb_with_exception(program_listing, profile_list=None):
             this_instruction['label'] = label_dict[lnum]
             assembly_listing.append(this_instruction)
         elif first_word == cmd_FUNCTION:
-            fun_name = this_line.split()[1].split('(', 1)[0]
+            fun_name = this_line.split()[1].split('()')[0]
             this_instruction['opcode'] = OP_JMP
             fun_end_lnum = func_lookup[fun_name]['fun_end']
             fun_end_label = f"FEND_{fun_name}@{fun_end_lnum}"
@@ -549,17 +494,18 @@ def make_dsb_with_exception(program_listing, profile_list=None):
             assembly_listing.append(this_instruction)
         elif first_word == cmd_END_FUNCTION:
             # RET, then NOP
-            assembly_listing += parse_return_value(this_line, cmd_END_FUNCTION)
             this_instruction['opcode'] = OP_RET
-            this_instruction['comment'] = this_line
+            this_instruction['comment'] = None
             assembly_listing.append(this_instruction)
             this_instruction = get_empty_instruction()
             this_instruction['comment'] = this_line
             this_instruction['label'] = label_dict[lnum]
             assembly_listing.append(this_instruction)
-        elif is_func_call(this_line, func_lookup):
-            inst_list = parse_exp_one_item(this_line, this_line)
-            assembly_listing += inst_list
+        elif first_word.endswith('()'):
+            fun_name = this_line.split('()')[0]
+            this_instruction['opcode'] = OP_CALL
+            this_instruction['oparg'] = label_dict[func_lookup[fun_name]['fun_start']]
+            assembly_listing.append(this_instruction)
         elif this_line.startswith(cmd_STRING) or first_word == cmd_OLED_PRINT:
             str_content = this_line.split(' ', 1)[-1]
             if str_content not in str_lookup:
@@ -588,9 +534,7 @@ def make_dsb_with_exception(program_listing, profile_list=None):
             this_instruction['comment'] = this_line
             assembly_listing.append(this_instruction)
         elif first_word == cmd_RETURN:
-            assembly_listing += parse_return_value(this_line, cmd_RETURN)
             this_instruction['opcode'] = OP_RET
-            this_instruction['comment'] = this_line
             assembly_listing.append(this_instruction)
         elif first_word == cmd_HALT:
             this_instruction['opcode'] = OP_HALT
@@ -700,16 +644,15 @@ def make_dsb_with_exception(program_listing, profile_list=None):
     for index, item in enumerate(assembly_listing):
         item['addr'] = index * INSTRUCTION_SIZE_BYTES
 
+    VAR_SIZE_BYTES = 2
     var_addr_dict = {}
     var_count = 0
-    # assign address to all user-defined variables
-    for item in user_var_lookup:
+    # assign address to all variables
+    for item in var_lookup:
         if item in reserved_variable_dict:
             var_addr_dict[item] = reserved_variable_dict[item]
         else:
-            var_addr_dict[item] = USER_VAR_START_ADDRESS + var_count * USER_VAR_BYTE_WIDTH
-            if var_addr_dict[item] > USER_VAR_END_ADDRESS_INCLUSIVE:
-                raise ValueError("Too Many User-defined Variables")
+            var_addr_dict[item] = var_count * VAR_SIZE_BYTES
             var_count += 1
 
     for item in assembly_listing:
@@ -717,7 +660,10 @@ def make_dsb_with_exception(program_listing, profile_list=None):
             item['oparg'] = var_addr_dict[item['oparg']]
 
     for item in reserved_variable_dict:
-        user_var_lookup.pop(item, None)
+        var_lookup.pop(item, None)
+
+    if len(var_lookup) > MAX_NUMBER_OF_VARIABLES:
+        raise ValueError("Too many variables")
 
     str_list = []
     for item in str_lookup:
@@ -753,8 +699,6 @@ def make_dsb_with_exception(program_listing, profile_list=None):
         if isinstance(item['oparg'], str) and "@" in item['oparg']:
             item['oparg'] = label_to_addr_dict[item['oparg']]
         if isinstance(item['oparg'], int) is False:
-            print(func_lookup)
-            print(item)
             current_line_content = item['comment']
             current_line_number_sf1 = item['lnum_sf1']
             raise ValueError("Unknown variable")
@@ -785,7 +729,7 @@ def make_dsb_with_exception(program_listing, profile_list=None):
     print('\n')
     # print("label_to_addr_dict:", label_to_addr_dict)  
     # print("var_addr_dict:", var_addr_dict)
-    # print('user_var_lookup:', user_var_lookup)
+    # print('var_lookup:', var_lookup)
     # print("str_bin_start:", str_bin_start)
     # print("str_list:", str_list)
     print(f'Binary Size: {len(output_bin_array)} Bytes')
@@ -799,9 +743,9 @@ def make_dsb_no_exception(program_listing, profile_list=None):
         return {'comments':str(e), 'error_line_str':current_line_content, 'error_line_number_starting_from_1':current_line_number_sf1}, None
 
 if __name__ == "__main__":
-    # Require at least input and output arguments
-    if len(sys.argv) < 2:
-        print(f"Usage: {__file__} <ds3_script> [output]")
+
+    if len(sys.argv) <= 2:
+        print(__file__, "ds3_script output")
         exit()
 
     text_file = open(sys.argv[1])
@@ -810,7 +754,7 @@ if __name__ == "__main__":
 
     program_listing = []
     for index, item in enumerate(text_listing):
-        program_listing.append(ds_line(item, index + 1))
+        program_listing.append(ds_line(item, index+1))
 
     status_dict, bin_arr = make_dsb_no_exception(program_listing)
 
@@ -820,7 +764,7 @@ if __name__ == "__main__":
             print(f'{key}: {status_dict[key]}')
         exit()
 
-    # Only write binary if output file argument provided
-    if len(sys.argv) >= 3:
-        with open(sys.argv[2], 'wb') as bin_out:
-            bin_out.write(bin_arr)
+    bin_out = open(sys.argv[2], 'wb')
+    bin_out.write(bin_arr)
+    bin_out.close()
+
diff --git a/src/myast.py b/src/myast.py
index 357cd22..84db8fa 100644
--- a/src/myast.py
+++ b/src/myast.py
@@ -2,7 +2,7 @@ import sys
 import ast
 
 def is_walkable(node):
-	return isinstance(node, ast.BinOp) or isinstance(node, ast.BoolOp) or isinstance(node, ast.Compare) or isinstance(node, ast.UnaryOp) or isinstance(node, ast.Call)
+	return isinstance(node, ast.BinOp) or isinstance(node, ast.BoolOp) or isinstance(node, ast.Compare) or isinstance(node, ast.UnaryOp)
 
 def get_right(node):
 	if isinstance(node, ast.UnaryOp) and isinstance(node.op, ast.USub):
@@ -35,13 +35,9 @@ def postorder_walk(node, action, instruction_list, expr):
 	if isinstance(node, ast.BoolOp):
 		for item in node.values:
 			postorder_walk(item, action, instruction_list, expr)
-	if isinstance(node, ast.Call):
-		for item in node.args:
-			postorder_walk(item, action, instruction_list, expr)
 	if is_leaf(node):
 		action(node, instruction_list)
 		return
 	postorder_walk(get_left(node), action, instruction_list, expr)
 	postorder_walk(get_right(node), action, instruction_list, expr)
 	action(node, instruction_list)
-
diff --git a/src/pong.txt b/src/pong.txt
deleted file mode 100644
index f64ac83..0000000
--- a/src/pong.txt
+++ /dev/null
@@ -1,144 +0,0 @@
-DEFINE BALL_RADIUS 2
-DEFINE PADDLE_WIDTH 2
-DEFINE PADDLE_HEIGHT 30
-DEFINE PADDLE_MOVEMENT_STEP 6
-DEFINE RE_CW 24
-DEFINE RE_CCW 25
-
-VAR $ball_pos_x = $_RANDOM_INT%100 + 10
-VAR $ball_pos_y = $_RANDOM_INT%100 + 10
-VAR $ball_velocity_x = 4
-VAR $ball_velocity_y = 3
-VAR $paddle_pos = 64
-VAR $active_key = 0
-VAR $score = 0
-
-VAR $paddle_upper_limit = PADDLE_HEIGHT/2
-VAR $paddle_lower_limit = 127-PADDLE_HEIGHT/2
-
-FUNCTION update_paddle_position()
-    IF $active_key == RE_CCW THEN
-        $paddle_pos = $paddle_pos + PADDLE_MOVEMENT_STEP
-        IF $paddle_pos > $paddle_lower_limit THEN
-            $paddle_pos = $paddle_lower_limit
-        END_IF
-    END_IF
-
-    IF $active_key == RE_CW THEN
-        $paddle_pos = $paddle_pos - PADDLE_MOVEMENT_STEP
-        IF $paddle_pos < $paddle_upper_limit THEN
-            $paddle_pos = $paddle_upper_limit
-        END_IF
-    END_IF
-END_FUNCTION
-
-FUNCTION draw_court()
-    OLED_LINE 0 0 127 0
-    OLED_LINE 0 127 127 127
-    OLED_LINE 127 0 127 127
-END_FUNCTION
-
-FUNCTION draw_paddle()
-    VAR $paddle_top_y = $paddle_pos - PADDLE_HEIGHT/2
-    VAR $paddle_bottom_y = $paddle_pos + PADDLE_HEIGHT/2
-    OLED_RECT 0 $paddle_top_y PADDLE_WIDTH $paddle_bottom_y 1
-END_FUNCTION
-
-FUNCTION draw_ball()
-    VAR $drawx = $ball_pos_x
-    VAR $drawy = $ball_pos_y
-
-    IF $drawx >= 127-BALL_RADIUS || $drawx <= BALL_RADIUS THEN
-        RETURN
-    END_IF
-    IF $drawy >= 127-BALL_RADIUS || $drawy <= BALL_RADIUS THEN
-        RETURN
-    END_IF
-
-    OLED_CIRCLE $drawx $drawy BALL_RADIUS 1
-END_FUNCTION
-
-FUNCTION draw_gameover()
-    SWC_FILL 255 0 0
-    OLED_CLEAR
-    draw_paddle()
-    draw_court()
-    draw_ball()
-    
-    OLED_CURSOR 20 40
-    OLED_PRINT GAME OVER
-    OLED_CURSOR 20 60
-    OLED_PRINT Score: $score
-    //OLED_CURSOR 20 80
-    //OLED_PRINT Anykey to quit
-    OLED_UPDATE
-    
-    BCLR
-    WHILE TRUE
-        IF $_BLOCKING_READKEY <= 20 THEN
-            SWC_RESET 99
-            HALT
-        END_IF
-    END_WHILE
-END_FUNCTION
-
-FUNCTION speed_up_ball()
-    IF $ball_velocity_x >= 0 THEN
-        $ball_velocity_x = $ball_velocity_x + ($_RANDOM_INT % 2)
-    ELSE IF $ball_velocity_x < 0 THEN
-        $ball_velocity_x = $ball_velocity_x - ($_RANDOM_INT % 2)
-    END_IF
-
-    IF $ball_velocity_y >= 0 THEN
-        $ball_velocity_y = $ball_velocity_y + ($_RANDOM_INT % 2)
-    ELSE IF $ball_velocity_y < 0 THEN
-        $ball_velocity_y = $ball_velocity_y - ($_RANDOM_INT % 2)
-    END_IF
-END_FUNCTION
-
-FUNCTION update_ball_pos()
-    $ball_pos_x = $ball_pos_x + $ball_velocity_x
-    $ball_pos_y = $ball_pos_y + $ball_velocity_y
-
-    IF ($ball_pos_y >= 127 - BALL_RADIUS*2) || ($ball_pos_y <= BALL_RADIUS*2) THEN
-        $ball_velocity_y = $ball_velocity_y * -1
-    END_IF
-
-    IF $ball_pos_x >= 127 - BALL_RADIUS*2 THEN
-        $ball_velocity_x = $ball_velocity_x * -1
-    END_IF
-
-    IF $ball_pos_x <= BALL_RADIUS*2 THEN
-        VAR $paddle_top = $paddle_pos - PADDLE_HEIGHT/2
-        VAR $paddle_bottom = $paddle_pos + PADDLE_HEIGHT/2
-        IF $ball_pos_y >= $paddle_top && $ball_pos_y <= $paddle_bottom THEN
-            $ball_velocity_x = $ball_velocity_x * -1
-            $score = $score + 1
-
-            speed_up_ball()
-
-            SWC_FILL $_RANDOM_INT%255 $_RANDOM_INT%255 $_RANDOM_INT%255
-        ELSE
-            $ball_velocity_x = 0
-            $ball_velocity_y = 0
-            draw_gameover()
-        END_IF
-    END_IF
-END_FUNCTION
-
-SWC_FILL 0 255 0
-
-WHILE TRUE
-    $active_key = $_READKEY
-    update_paddle_position()
-
-    update_ball_pos()
-
-    OLED_CLEAR
-    draw_paddle()
-    draw_court()
-    draw_ball()
-    OLED_UPDATE
-    DELAY 20
-
-END_WHILE
diff --git a/src/requirements.txt b/src/requirements.txt
deleted file mode 100644
index 2d7ffa5..0000000
--- a/src/requirements.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-platformdirs
-hidapi
-pywin32 ; sys_platform == 'win32'
-psutil
-pyinstaller
\ No newline at end of file
diff --git a/src/shared.py b/src/shared.py
index 34f9ced..b0b5245 100644
--- a/src/shared.py
+++ b/src/shared.py
@@ -406,62 +406,80 @@ cmd_MK_PLAYPAUSE : (KEY_MK_PLAYPAUSE, KEY_TYPE_MEDIA),
 cmd_MK_STOP : (KEY_MK_STOP, KEY_TYPE_MEDIA),
 }
 
-INSTRUCTION_SIZE_BYTES = 3
-USER_VAR_START_ADDRESS = 0xFA00
-USER_VAR_BYTE_WIDTH = 4
-USER_VAR_END_ADDRESS_INCLUSIVE = 0xFBFF
-
-PGV_COUNT = 32
-PGV_START_ADDRESS = 0xFD80
-PGV_BYTE_WIDTH = 4
-PGV_END_ADDRESS_INCLUSIVE = 0xFDFF
-
-INTERAL_VAR_START_ADDRESS = 0xFE00
-INTERAL_VAR_BYTE_WIDTH = 4
-INTERAL_VAR_END_ADDRESS_INCLUSIVE = 0xFFFF
+GV_OFFSET = 64
 
 internal_variable_dict = {
-    '_DEFAULTDELAY': (INTERAL_VAR_START_ADDRESS + 0 * INTERAL_VAR_BYTE_WIDTH),
-    '_DEFAULTCHARDELAY': (INTERAL_VAR_START_ADDRESS + 1 * INTERAL_VAR_BYTE_WIDTH),
-    '_CHARJITTER': (INTERAL_VAR_START_ADDRESS + 2 * INTERAL_VAR_BYTE_WIDTH),
-    "_RANDOM_MIN": (INTERAL_VAR_START_ADDRESS + 3 * INTERAL_VAR_BYTE_WIDTH),
-    "_RANDOM_MAX": (INTERAL_VAR_START_ADDRESS + 4 * INTERAL_VAR_BYTE_WIDTH),
-    "_RANDOM_INT": (INTERAL_VAR_START_ADDRESS + 5 * INTERAL_VAR_BYTE_WIDTH),
-    "_TIME_MS": (INTERAL_VAR_START_ADDRESS + 6 * INTERAL_VAR_BYTE_WIDTH),
-    "_READKEY": (INTERAL_VAR_START_ADDRESS + 7 * INTERAL_VAR_BYTE_WIDTH),
-    "_LOOP_SIZE": (INTERAL_VAR_START_ADDRESS + 8 * INTERAL_VAR_BYTE_WIDTH),
-    "_KEYPRESS_COUNT": (INTERAL_VAR_START_ADDRESS + 9 * INTERAL_VAR_BYTE_WIDTH),
-    "_NEEDS_EPILOGUE": (INTERAL_VAR_START_ADDRESS + 10 * INTERAL_VAR_BYTE_WIDTH),
-    "_TIME_S": (INTERAL_VAR_START_ADDRESS + 11 * INTERAL_VAR_BYTE_WIDTH),
-    "_ALLOW_ABORT": (INTERAL_VAR_START_ADDRESS + 12 * INTERAL_VAR_BYTE_WIDTH),
-    "_BLOCKING_READKEY": (INTERAL_VAR_START_ADDRESS + 13 * INTERAL_VAR_BYTE_WIDTH),
-    "_IS_NUMLOCK_ON": (INTERAL_VAR_START_ADDRESS + 14 * INTERAL_VAR_BYTE_WIDTH),
-    "_IS_CAPSLOCK_ON": (INTERAL_VAR_START_ADDRESS + 15 * INTERAL_VAR_BYTE_WIDTH),
-    "_IS_SCROLLLOCK_ON": (INTERAL_VAR_START_ADDRESS + 16 * INTERAL_VAR_BYTE_WIDTH),
-    "_DONT_REPEAT": (INTERAL_VAR_START_ADDRESS + 17 * INTERAL_VAR_BYTE_WIDTH),
-    "_THIS_KEYID": (INTERAL_VAR_START_ADDRESS + 18 * INTERAL_VAR_BYTE_WIDTH),
-    "_DP_MODEL": (INTERAL_VAR_START_ADDRESS + 19 * INTERAL_VAR_BYTE_WIDTH),
-    "_RTC_IS_VALID": (INTERAL_VAR_START_ADDRESS + 20 * INTERAL_VAR_BYTE_WIDTH),
-    "_RTC_UTC_OFFSET": (INTERAL_VAR_START_ADDRESS + 21 * INTERAL_VAR_BYTE_WIDTH),
-    "_RTC_YEAR": (INTERAL_VAR_START_ADDRESS + 22 * INTERAL_VAR_BYTE_WIDTH),
-    "_RTC_MONTH": (INTERAL_VAR_START_ADDRESS + 23 * INTERAL_VAR_BYTE_WIDTH),
-    "_RTC_DAY": (INTERAL_VAR_START_ADDRESS + 24 * INTERAL_VAR_BYTE_WIDTH),
-    "_RTC_HOUR": (INTERAL_VAR_START_ADDRESS + 25 * INTERAL_VAR_BYTE_WIDTH),
-    "_RTC_MINUTE": (INTERAL_VAR_START_ADDRESS + 26 * INTERAL_VAR_BYTE_WIDTH),
-    "_RTC_SECOND": (INTERAL_VAR_START_ADDRESS + 27 * INTERAL_VAR_BYTE_WIDTH),
-    "_RTC_WDAY": (INTERAL_VAR_START_ADDRESS + 28 * INTERAL_VAR_BYTE_WIDTH),
-    "_RTC_YDAY": (INTERAL_VAR_START_ADDRESS + 29 * INTERAL_VAR_BYTE_WIDTH),
-    "_STR_PRINT_FORMAT": (INTERAL_VAR_START_ADDRESS + 30 * INTERAL_VAR_BYTE_WIDTH),
-    "_STR_PRINT_PADDING": (INTERAL_VAR_START_ADDRESS + 31 * INTERAL_VAR_BYTE_WIDTH),
+    '_DEFAULTDELAY': (0xffff - 0),
+    '_DEFAULTCHARDELAY': (0xffff - 1),
+    '_CHARJITTER': (0xffff - 2),
+    "_RANDOM_MIN": (0xffff - 3),
+    "_RANDOM_MAX": (0xffff - 4),
+    "_RANDOM_INT": (0xffff - 5),
+    "_TIME_MS": (0xffff - 6),
+    "_READKEY": (0xffff - 7),
+    "_LOOP_SIZE": (0xffff - 8),
+    "_KEYPRESS_COUNT": (0xffff - 9),
+    "_NEEDS_EPILOGUE": (0xffff - 10),
+    "_TIME_S": (0xffff - 11),
+    "_ALLOW_ABORT": (0xffff - 12),
+    "_BLOCKING_READKEY": (0xffff - 13),
+    "_IS_NUMLOCK_ON": (0xffff - 14),
+    "_IS_CAPSLOCK_ON": (0xffff - 15),
+    "_IS_SCROLLLOCK_ON": (0xffff - 16),
+    "_DONT_REPEAT": (0xffff - 17),
+    "_THIS_KEYID": (0xffff - 18),
+    "_DP_MODEL": (0xffff - 19),
+    "_RTC_IS_VALID": (0xffff - 20),
+    "_RTC_UTC_OFFSET": (0xffff - 21),
+    "_RTC_YEAR": (0xffff - 22),
+    "_RTC_MONTH": (0xffff - 23),
+    "_RTC_DAY": (0xffff - 24),
+    "_RTC_HOUR": (0xffff - 25),
+    "_RTC_MINUTE": (0xffff - 26),
+    "_RTC_SECOND": (0xffff - 27),
+    "_RTC_WDAY": (0xffff - 28),
+    "_RTC_YDAY": (0xffff - 29),
+    "_STR_PRINT_FORMAT": (0xffff - 30),
+    "_STR_PRINT_PADDING": (0xffff - 31),
 }
 
-global_variable_dict = {}
-for i in range(PGV_COUNT):
-    global_variable_dict[f"_GV{i}"] = PGV_START_ADDRESS + i * PGV_BYTE_WIDTH
-
-FUNC_NAME_MANGLE_PREFIX = "_FUNARG_"
+global_variable_dict = {
+    "_GV0": (0xffff - GV_OFFSET - 0),
+    "_GV1": (0xffff - GV_OFFSET - 1),
+    "_GV2": (0xffff - GV_OFFSET - 2),
+    "_GV3": (0xffff - GV_OFFSET - 3),
+    "_GV4": (0xffff - GV_OFFSET - 4),
+    "_GV5": (0xffff - GV_OFFSET - 5),
+    "_GV6": (0xffff - GV_OFFSET - 6),
+    "_GV7": (0xffff - GV_OFFSET - 7),
+    "_GV8": (0xffff - GV_OFFSET - 8),
+    "_GV9": (0xffff - GV_OFFSET - 9),
+    "_GV10": (0xffff - GV_OFFSET - 10),
+    "_GV11": (0xffff - GV_OFFSET - 11),
+    "_GV12": (0xffff - GV_OFFSET - 12),
+    "_GV13": (0xffff - GV_OFFSET - 13),
+    "_GV14": (0xffff - GV_OFFSET - 14),
+    "_GV15": (0xffff - GV_OFFSET - 15),
+    "_GV16": (0xffff - GV_OFFSET - 16),
+    "_GV17": (0xffff - GV_OFFSET - 17),
+    "_GV18": (0xffff - GV_OFFSET - 18),
+    "_GV19": (0xffff - GV_OFFSET - 19),
+    "_GV20": (0xffff - GV_OFFSET - 20),
+    "_GV21": (0xffff - GV_OFFSET - 21),
+    "_GV22": (0xffff - GV_OFFSET - 22),
+    "_GV23": (0xffff - GV_OFFSET - 23),
+    "_GV24": (0xffff - GV_OFFSET - 24),
+    "_GV25": (0xffff - GV_OFFSET - 25),
+    "_GV26": (0xffff - GV_OFFSET - 26),
+    "_GV27": (0xffff - GV_OFFSET - 27),
+    "_GV28": (0xffff - GV_OFFSET - 28),
+    "_GV29": (0xffff - GV_OFFSET - 29),
+    "_GV30": (0xffff - GV_OFFSET - 30),
+    "_GV31": (0xffff - GV_OFFSET - 31),
+}
 
 reserved_variable_dict = internal_variable_dict | global_variable_dict
+MAX_NUMBER_OF_VARIABLES = 64
 
 class ds_line:
     def __init__(self, content, lnum_sf1=-1, pplnum=-1):
@@ -715,10 +733,4 @@ def get_profile_dir(dir_path):
             return full_path
     return None
 
-def is_func_call(pgm_line, func_dict):
-    for key in func_dict:
-        if pgm_line.startswith(key+"("):
-            return True
-    return False
-
 # unzip_to_own_directory("duckyPad_Profile_Photoshop.zip", "output")
\ No newline at end of file
diff --git a/src/test.txt b/src/test.txt
deleted file mode 100644
index 62ab26a..0000000
--- a/src/test.txt
+++ /dev/null
@@ -1,10 +0,0 @@
-FUNCTION myadd(a, b)
-
-
-
-	VAR $test = a + 2
-END_FUNCTION
-
-myadd(6, 9)
-
-$test = a + b
\ No newline at end of file
