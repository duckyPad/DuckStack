// ---------------------------------------------------------
// DuckyScript Compiler Stress Test
// Target: Constant Folding & Dead Code Elimination
// ---------------------------------------------------------

// SECTION 1: CONSTANT FOLDING
// The compiler should pre-calculate these values.
// In the final bytecode, these should be simple integer pushes, 
// not sequences of ADD/MULT/DIV instructions.

VAR fold_math_simple = 10 + 20          // Expect: 30
VAR fold_math_order  = 5 + 10 * 2       // Expect: 25 (Order of operations)
VAR fold_math_paren  = (5 + 10) * 2     // Expect: 30
VAR fold_negative    = 100 - 150        // Expect: -50

// Logical folding
// 1 is True, 0 is False in DuckyScript
VAR fold_logic_and   = (1 == 1) && (10 > 5)  // Expect: 1
VAR fold_logic_or    = (0 == 1) || (5 < 10)  // Expect: 1
VAR fold_logic_fail  = (50 < 10)             // Expect: 0

// Printing results to verify runtime correctness
STRINGLN Math Check: $fold_math_order (Should be 25)
STRINGLN Logic Check: $fold_logic_and (Should be 1)

// ---------------------------------------------------------

// SECTION 2: DEAD BRANCH ELIMINATION
// The optimizer should detect these conditions are always False/True.

// 2.1: Dead IF block
// Since the condition is constant 0, this entire block (including the string)
// should be removed from the AST/Bytecode.
IF 0
    STRINGLN [FAIL] Dead IF branch was executed!
    DELAY 5000
    WINDOWS r
END_IF

// 2.2: Dead ELSE path
// Condition is constant 1. The IF body keeps, the ELSE body dies.
IF 1
    STRINGLN [PASS] Alive IF branch executed.
ELSE
    STRINGLN [FAIL] Dead ELSE branch executed!
END_IF

// 2.3: Dead WHILE loop
// This loop should be entirely stripped.
WHILE 0
    STRINGLN [FAIL] Infinite loop start...
    DELAY 1000
END_WHILE

// ---------------------------------------------------------

// SECTION 3: DEAD FUNCTION ELIMINATION
// Some functions are defined but never called.

// 3.1: Used Function (Keep)
FUN keep_me()
    STRINGLN [PASS] keep_me() was called.
END_FUN

// 3.2: Unused Function (Eliminate)
// This function is never called in the global scope or by other functions.
// It should not appear in the generated bytecode.
FUN delete_me()
    STRINGLN [FAIL] delete_me() was called!
    REPEAT 100
END_FUN

// 3.3: Recursive Function (Keep)
// Ideally, your optimizer should recognize self-recursion doesn't mean "unused".
// It is called by 'call_recursive_wrapper', which is called by main.
FUN factorial_recursive(n)
    IF n <= 1
        RETURN 1
    END_IF
    RETURN n * factorial_recursive(n - 1)
END_FUN

// 3.4: Nested Call Wrapper (Keep)
FUN call_recursive_wrapper()
    VAR res = factorial_recursive(5)
    STRINGLN Factorial 5 is $res
END_FUN

// ---------------------------------------------------------

// SECTION 4: UNREACHABLE CODE (After Return)
// Code immediately following a RETURN (in the same block) is dead.

FUN early_return_test()
    STRINGLN [PASS] About to return...
    RETURN
    
    // The optimizer should strip everything below this line inside this function
    STRINGLN [FAIL] Code after RETURN executed!
    DELAY 10000
END_FUN

// ---------------------------------------------------------

// EXECUTION ENTRY POINT
// Trigger the functions that are supposed to survive.

keep_me()
early_return_test()
call_recursive_wrapper()

// Final sanity check
STRINGLN Stress Test Complete.