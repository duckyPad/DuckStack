// ==========================================
// DuckyScript Constant Folding Stress Test
// ==========================================
// This script performs operations on constants.
// A perfect optimizer should resolve ALL 'VAR' assignments 
// to single constants at compile time.

STRINGLN === STARTING CONSTANT FOLDING TEST ===
DELAY 500

// ------------------------------------------
// 1. Basic Arithmetic (Signed)
// ------------------------------------------
STRINGLN [TEST 1] Basic Arithmetic

// Simple Addition
VAR t1_add = 100 + 55
STRINGLN 100 + 55 | Got: $t1_add | Expect: 155

// Order of Operations (PEMDAS)
VAR t1_pemdas = 10 + 5 * 4 - 6 / 2
STRINGLN 10 + 5 * 4 - 6 / 2 | Got: $t1_pemdas | Expect: 27

// Negative Numbers
VAR t1_neg = -10 + -20
STRINGLN -10 + -20 | Got: $t1_neg | Expect: -30

// Parenthesis priority
VAR t1_paren = (10 + 5) * (4 - 2)
STRINGLN (10 + 5) * (4 - 2) | Got: $t1_paren | Expect: 30

// Exponent
VAR t1_pow = 2 ** 10
STRINGLN 2 ** 10 | Got: $t1_pow | Expect: 1024

// ------------------------------------------
// 2. Division and Modulus (Signed)
// ------------------------------------------
// DuckStack uses C-style integer division (Truncate towards zero)
STRINGLN [TEST 2] Signed Div/Mod

VAR t2_div = -100 / 10
STRINGLN -100 / 10 | Got: $t2_div | Expect: -10

// Integer truncation check (e.g. 5/2 = 2)
VAR t2_trunc = 5 / 2
STRINGLN 5 / 2 | Got: $t2_trunc | Expect: 2

// Negative truncation (e.g. -5/2 = -2)
VAR t2_trunc_neg = -5 / 2
STRINGLN -5 / 2 | Got: $t2_trunc_neg | Expect: -2

// Modulus (Result usually takes sign of dividend in C)
VAR t2_mod = -10 % 3
STRINGLN -10 % 3 | Got: $t2_mod | Expect: -1

VAR t2_mod2 = 10 % -3
STRINGLN 10 % -3 | Got: $t2_mod2 | Expect: 1

// ------------------------------------------
// 3. Bitwise Operations
// ------------------------------------------
STRINGLN [TEST 3] Bitwise Ops

// AND / OR / XOR
VAR t3_and = 255 & 15
STRINGLN 255 & 15 | Got: $t3_and | Expect: 15

VAR t3_or = 240 | 15
STRINGLN 240 | 15 | Got: $t3_or | Expect: 255

VAR t3_xor = 255 ^ 15
STRINGLN 255 ^ 15 | Got: $t3_xor | Expect: 240

// NOT (Inverts bits of 32-bit signed integer)
// ~0 is -1
VAR t3_not = ~0
STRINGLN ~0 | Got: $t3_not | Expect: -1

// ~10 (0...01010) -> (1...10101) = -11
VAR t3_not2 = ~10
STRINGLN ~10 | Got: $t3_not2 | Expect: -11

// Left Shift
VAR t3_lsl = 1 << 4
STRINGLN 1 << 4 | Got: $t3_lsl | Expect: 16

// Arithmetic Right Shift (Sign Extended)
// -16 is 111...1110000. Shifting right preserves the 1s.
VAR t3_asr = -16 >> 2
STRINGLN -16 >> 2 | Got: $t3_asr | Expect: -4

// ------------------------------------------
// 4. Comparison & Logical (Boolean)
// ------------------------------------------
// DuckStack: True is 1, False is 0
STRINGLN [TEST 4] Logic & Compare

VAR t4_gt = 10 > 5
STRINGLN 10 > 5 | Got: $t4_gt | Expect: 1

VAR t4_lte = 10 <= 5
STRINGLN 10 <= 5 | Got: $t4_lte | Expect: 0

VAR t4_eq = -5 == -5
STRINGLN -5 == -5 | Got: $t4_eq | Expect: 1

// Logical AND (&&) - Short circuit checks usually happen at runtime,
// but constants should be foldable.
VAR t4_land = 1 && 1
STRINGLN 1 && 1 | Got: $t4_land | Expect: 1

VAR t4_land2 = 100 && 0
STRINGLN 100 && 0 | Got: $t4_land2 | Expect: 0

// Logical OR (||)
VAR t4_lor = 0 || 5
STRINGLN 0 || 5 | Got: $t4_lor | Expect: 1

// Logical NOT (!)
VAR t4_lnot = !100
STRINGLN !100 | Got: $t4_lnot | Expect: 0

VAR t4_lnot2 = !0
STRINGLN !0 | Got: $t4_lnot2 | Expect: 1

// ------------------------------------------
// 5. Unsigned Functions (Built-ins)
// ------------------------------------------
// If your optimizer folds built-ins, these should be pre-calculated.
// If not, they will run at runtime (still valid for correctness check).
STRINGLN [TEST 5] Unsigned Built-ins

// Logical Shift Right (Zero Extend)
// -1 is 0xFFFFFFFF. LSR 1 should result in 0x7FFFFFFF (2147483647)
VAR t5_lsr = LSR(-1, 1)
STRINGLN LSR(-1, 1) | Got: $t5_lsr | Expect: 2147483647

// Unsigned comparison
// -1 (0xFFFFFFFF) is bigger than 10 (0x0000000A) in unsigned world
VAR t5_ugt = UGT(-1, 10)
STRINGLN UGT(-1, 10) | Got: $t5_ugt | Expect: 1

VAR t5_ult = ULT(-1, 10)
STRINGLN ULT(-1, 10) | Got: $t5_ult | Expect: 0

// Unsigned Division
// -1 (MAX_UINT) / 2
// 4294967295 / 2 = 2147483647
VAR t5_udiv = UDIV(-1, 2)
STRINGLN UDIV(-1, 2) | Got: $t5_udiv | Expect: 2147483647

// ------------------------------------------
// 6. Edge Cases & Overflows (32-bit)
// ------------------------------------------
STRINGLN [TEST 6] Edge Cases

// Overflow (Positive Wrap)
// 2147483647 + 1 = -2147483648
VAR t6_ovf = 2147483647 + 1
STRINGLN MAX_INT + 1 | Got: $t6_ovf | Expect: -2147483648

// Underflow (Negative Wrap)
// -2147483648 - 1 = 2147483647
VAR t6_udf = -2147483648 - 1
STRINGLN MIN_INT - 1 | Got: $t6_udf | Expect: 2147483647

// Multiplication Overflow
// 65536 * 65536 = 4,294,967,296 -> Wraps to 0
VAR t6_mul = 65536 * 65536
STRINGLN 65536 * 65536 | Got: $t6_mul | Expect: 0

STRINGLN === TEST COMPLETE ===