REM_BLOCK
    OPTIMIZER STRESS TEST
    ---------------------
    1. Constant Folding: Only folds operators unaffected by _UNSIGNED_MATH
    2. Dead Code Elimination: Functions never called should be removed
END_REM

STRINGLN --- STARTING OPTIMIZER TEST ---

// ==========================================
// SECTION 1: SAFE CONSTANT FOLDING
// These operators are consistent regardless of math mode.
// Your optimizer SHOULD fold these into single constants.
// ==========================================

// 1. Basic Arithmetic (+, -, *, **)
// Expect: PUSHC 25
VAR fold_math = 10 + 5 * 3
STRINGLN [TEST 1] Math (10+5*3): $fold_math%d (Expect 25)

// 2. Power (**)
// Expect: PUSHC 256
VAR fold_pow = 2 ** 8
STRINGLN [TEST 2] Power (2^8): $fold_pow%d (Expect 256)

// 3. Bitwise Logic (&, |, ^, ~)
// Expect: PUSHC 15 (12 | 3)
VAR fold_bits = (12 | 3) & 15
STRINGLN [TEST 3] Bitwise: $fold_bits%d (Expect 15)

// 4. Logical Operators (&&, ||, !)
// Expect: PUSHC 1 (True)
VAR fold_logic = (1 && 0) || (5 == 5)
STRINGLN [TEST 4] Logic: $fold_logic%d (Expect 1)

// 5. Left Shift (<<)
// Safe because it doesn't depend on sign extension like RSHIFT
// Expect: PUSHC 32
VAR fold_lshift = 2 << 4
STRINGLN [TEST 5] LShift: $fold_lshift%d (Expect 32)

// 6. Equality (==, !=)
// Safe because exact bitmatch is mode-agnostic
// Expect: PUSHC 1
VAR fold_eq = 100 != 50
STRINGLN [TEST 6] Equality: $fold_eq%d (Expect 1)


// ==========================================
// SECTION 2: UNSAFE FOLDING TRAPS
// These operators depend on _UNSIGNED_MATH.
// Your optimizer MUST NOT fold these, as the user
// might change the mode at runtime.
// ==========================================

// 1. Division and Modulo (DIV, MOD)
// If folded, you assume signed/unsigned behavior prematurely.
VAR no_fold_div = -100 / 2
VAR no_fold_mod = -5 % 2

// 2. Right Shift (RSHIFT)
// Signed mode = Arithmetic Shift (sign extends)
// Unsigned mode = Logical Shift (zero extends)
VAR no_fold_rshift = -16 >> 2

// 3. Range Comparisons (<, >, <=, >=)
// -1 is LESS than 1 in Signed, but GREATER in Unsigned (0xFFFFFFFF)
VAR no_fold_cmp = -1 < 1

STRINGLN [TEST 7] Unsafe Ops (Should calc at runtime):
STRINGLN    Div (-50): $no_fold_div%d
STRINGLN    Mod (-1):  $no_fold_mod%d
STRINGLN    RShift:    $no_fold_rshift%d
STRINGLN    Cmp (1):   $no_fold_cmp%d

// Demonstrating why: Change mode and re-run unsafe ops
// If you folded above, these results won't change (which would be WRONG)
_UNSIGNED_MATH = 1
STRINGLN --- Switched to Unsigned Mode ---
STRINGLN [TEST 8] RShift in Unsigned (Expect Huge Number):
VAR runtime_calc = -16 >> 2
STRINGLN    Result: $runtime_calc%u


// ==========================================
// SECTION 3: DEAD FUNCTION ELIMINATION
// ==========================================

// Case A: The "Ghost" Function
// Completely unreferenced. Should be removed.
FUN dead_ghost()
    STRINGLN FAIL: Ghost function ran!
    HALT
END_FUN

// Case B: The "Transitive" Dead Chain
// Only called by other dead functions.
// If dead_parent() is removed, dead_child() should be too.
FUN dead_child()
    STRINGLN FAIL: Dead child ran!
    HALT
END_FUN

FUN dead_parent()
    dead_child()
END_FUN

// Case C: The "Live" Function
// Called by main. Must be kept.
FUN live_func()
    STRINGLN [TEST 9] Live function executed.
END_FUN

// Case D: The "Live" Chain
// Called by a live function. Must be kept.
FUN live_helper()
    STRINGLN [TEST 10] Live helper executed.
END_FUN

FUN live_complex()
    live_helper()
END_FUN

// Execution of live paths
live_func()
live_complex()

STRINGLN --- TEST COMPLETE ---