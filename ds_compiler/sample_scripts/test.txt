// DuckStack Compiler Stress Test
// Verifies Push Order (R-to-L) and Stack Arithmetic

STRINGLN --- STARTING STRESS TEST ---

// ---------------------------------------------------------
// TEST 1: Binary Operator Order (Subtraction)
// ---------------------------------------------------------
// Spec: SUB pops LHS first, then RHS.
// Expression: 10 - 2
// Required Stack: [2, 10 (TOS)]
// If your compiler pushes L-to-R (10 then 2), VM calculates 2 - 10 = -8.
VAR sub_test = 10 - 2
STRINGLN [TEST 1] Subtraction (10 - 2)
STRINGLN Expected: 8
STRINGLN Actual:   $sub_test

// ---------------------------------------------------------
// TEST 2: Division (Non-Commutative)
// ---------------------------------------------------------
// Expression: 100 / 5
VAR div_test = 100 / 5
STRINGLN [TEST 2] Division (100 / 5)
STRINGLN Expected: 20
STRINGLN Actual:   $div_test

// ---------------------------------------------------------
// TEST 3: Operator Precedence & Grouping
// ---------------------------------------------------------
// Should evaluate inner parenthesis first.
// ((10 + 2) * 2) - 5
// (12 * 2) - 5
// 24 - 5 = 19
VAR math_complex = ((10 + 2) * 2) - 5
STRINGLN [TEST 3] Precedence ((10+2)*2)-5
STRINGLN Expected: 19
STRINGLN Actual:   $math_complex

// ---------------------------------------------------------
// TEST 4: Comparison Logic
// ---------------------------------------------------------
// 10 > 5 should be 1 (True).
// If stack is flipped, it calculates 5 > 10 (False/0).
VAR bool_test = 10 > 5
STRINGLN [TEST 4] Logic (10 > 5)
STRINGLN Expected: 1
STRINGLN Actual:   $bool_test

// ---------------------------------------------------------
// TEST 5: Function Argument Order
// ---------------------------------------------------------
// Spec: Caller pushes arguments right to left.
// Func: check_order(a, b, c)
// Call: check_order(1, 2, 3)
//
// Stack Snapshot expected at call:
// [ ... | 3 | 2 | 1 (TOS) ]
// FP+4 = a (1)
// FP+8 = b (2)
// FP+12 = c (3)

FUN check_order(a, b, c)
    // We construct a unique number based on position
    // If a=1, b=2, c=3: 1 + 20 + 300 = 321
    // If reversed:      3 + 20 + 100 = 123
    VAR result = a + (b * 10) + (c * 100)
    RETURN result
END_FUN

VAR func_res = check_order(1, 2, 3)
STRINGLN [TEST 5] Func Args check_order(1, 2, 3)
STRINGLN Expected: 321
STRINGLN Actual:   $func_res

// ---------------------------------------------------------
// TEST 6: Recursion & Stack Frames
// ---------------------------------------------------------
// Verifies FP is restored correctly after RET.

FUN factorial(n)
    IF n <= 1
        RETURN 1
    END_IF
    RETURN n * factorial(n - 1)
END_FUN

VAR fact_res = factorial(5)
STRINGLN [TEST 6] Recursion (Factorial 5)
STRINGLN Expected: 120
STRINGLN Actual:   $fact_res

STRINGLN --- END TEST ---