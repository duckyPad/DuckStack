// =================================================================================
// DuckStack Optimization Stress Test
// Targets: Constant Folding & Dead Function Elimination
// =================================================================================

// ---------------------------------------------------------------------------------
// SECTION 1: DEAD FUNCTION ELIMINATION
// ---------------------------------------------------------------------------------
// These functions are NEVER called. 
// If your optimizer works, their bytecode and strings (e.g., "ERROR...") should 
// NOT appear in the final binary.

FUN dead_function_simple()
    STRINGLN ERROR: Dead function simple executed!
    VAR unused = 100
    unused = unused * 50
END_FUN

FUN dead_function_recursive(n)
    IF n > 0
        dead_function_recursive(n - 1)
    END_IF
    STRINGLN ERROR: Dead function recursive executed!
END_FUN

FUN dead_function_complex()
    // Using distinct Hex values to make them easy to grep in a binary dump
    VAR a = 0xDEAD
    VAR b = 0xBEEF
    VAR c = a ^ b
    STRINGLN ERROR: Dead function complex executed with $c%X
END_FUN

// ---------------------------------------------------------------------------------
// MAIN EXECUTION START
// ---------------------------------------------------------------------------------

STRINGLN --- START OPTIMIZATION TEST ---

// ---------------------------------------------------------------------------------
// SECTION 2: CONSTANT FOLDING - SIGNED ARITHMETIC
// ---------------------------------------------------------------------------------
// The optimizer should pre-calculate these values.
// Reference: Variables are 32-bit signed integers.

STRINGLN [TEST 1] Signed Arithmetic Folding

// Simple Math: (10 * 5) + (100 / 2) - 5 = 50 + 50 - 5 = 95
VAR fold_math_1 = 10 * 5 + 100 / 2 - 5
STRINGLN    Expr: 10 * 5 + 100 / 2 - 5
STRINGLN    Result: $fold_math_1%d (Expected: 95)

// Order of Operations: 5 + 3 * 4 = 17 (NOT 32)
VAR fold_math_2 = 5 + 3 * 4
STRINGLN    Expr: 5 + 3 * 4
STRINGLN    Result: $fold_math_2%d (Expected: 17)

// Parentheses: (5 + 3) * 4 = 32
VAR fold_math_3 = (5 + 3) * 4
STRINGLN    Expr: (5 + 3) * 4
STRINGLN    Result: $fold_math_3%d (Expected: 32)

// Negative Numbers: -10 * -5 = 50
VAR fold_math_4 = -10 * -5
STRINGLN    Expr: -10 * -5
STRINGLN    Result: $fold_math_4%d (Expected: 50)

// Hex Constants: 0x10 (16) + 0xA (10) = 26
VAR fold_math_5 = 0x10 + 0xA
STRINGLN    Expr: 0x10 + 0xA
STRINGLN    Result: $fold_math_5%d (Expected: 26)

// ---------------------------------------------------------------------------------
// SECTION 3: CONSTANT FOLDING - BITWISE OPERATIONS
// ---------------------------------------------------------------------------------

STRINGLN [TEST 2] Bitwise Operations

// AND: 0xFF (255) & 0x0F (15) = 0x0F (15)
VAR fold_bit_1 = 0xFF & 0x0F
STRINGLN    Expr: 0xFF & 0x0F
STRINGLN    Result: $fold_bit_1%X (Expected: F)

// OR: 0xF0 (240) | 0x0F (15) = 0xFF (255)
VAR fold_bit_2 = 0xF0 | 0x0F
STRINGLN    Expr: 0xF0 | 0x0F
STRINGLN    Result: $fold_bit_2%X (Expected: FF)

// XOR: 0xAA (10101010) ^ 0x55 (01010101) = 0xFF (11111111)
VAR fold_bit_3 = 0xAA ^ 0x55
STRINGLN    Expr: 0xAA ^ 0x55
STRINGLN    Result: $fold_bit_3%X (Expected: FF)

// Shift Left: 1 << 4 = 16
VAR fold_shift_1 = 1 << 4
STRINGLN    Expr: 1 << 4
STRINGLN    Result: $fold_shift_1%d (Expected: 16)

// Shift Right (Arithmetic): -16 (0xFFFFFFF0) >> 2 = -4 (0xFFFFFFFC)
// Ensures sign extension is handled correctly during folding
VAR fold_shift_2 = -16 >> 2
STRINGLN    Expr: -16 >> 2 (Arithmetic)
STRINGLN    Result: $fold_shift_2%d (Expected: -4)

// ---------------------------------------------------------------------------------
// SECTION 4: CONSTANT FOLDING - LOGICAL & COMPARISON
// ---------------------------------------------------------------------------------
// Results should be 0 (False) or 1 (True).

STRINGLN [TEST 3] Logical & Comparison

// Greater Than: 10 > 5 = 1
VAR fold_log_1 = 10 > 5
STRINGLN    Expr: 10 > 5
STRINGLN    Result: $fold_log_1 (Expected: 1)

// Equality: 0x5 == 5 = 1
VAR fold_log_2 = 0x5 == 5
STRINGLN    Expr: 0x5 == 5
STRINGLN    Result: $fold_log_2 (Expected: 1)

// Logical AND: (10 > 5) && (3 < 4) = 1 && 1 = 1
VAR fold_log_3 = (10 > 5) && (3 < 4)
STRINGLN    Expr: (10 > 5) && (3 < 4)
STRINGLN    Result: $fold_log_3 (Expected: 1)

// Logical OR with Zero: 0 || 1 = 1
VAR fold_log_4 = 0 || 1
STRINGLN    Expr: 0 || 1
STRINGLN    Result: $fold_log_4 (Expected: 1)

// ---------------------------------------------------------------------------------
// SECTION 5: UNSIGNED OPERATORS (BUILT-INS)
// ---------------------------------------------------------------------------------
// If your optimizer handles built-in function calls with constant args,
// these should be pre-calculated.

STRINGLN [TEST 4] Unsigned Operations (Built-ins)

// UDIV: -10 (0xFFFFFFF6) / 2 (Unsigned interpretation)
// 0xFFFFFFF6 / 2 = 2147483643 (0x7FFFFFFB)
VAR fold_unsigned_1 = UDIV(-10, 2) 
STRINGLN    Expr: UDIV(-10, 2)
STRINGLN    Result: $fold_unsigned_1%u (Expected: 2147483643)

// LSR (Logical Shift Right): -4 (0xFFFFFFFC) >> 1
// Arithmetic shift would be -2 (0xFFFFFFFE).
// Logical shift should be 0x7FFFFFFE (2147483646).
VAR fold_unsigned_2 = LSR(-4, 1)
STRINGLN    Expr: LSR(-4, 1)
STRINGLN    Result: $fold_unsigned_2%X (Expected: 7FFFFFFE)

// ---------------------------------------------------------------------------------
// SECTION 6: MIXED VARIABLES AND CONSTANTS
// ---------------------------------------------------------------------------------
// Ensure the optimizer handles partial folding (constants inside dynamic expressions).

STRINGLN [TEST 5] Mixed Variables & Constants

FUN mixed_math(input_val)
    // The "5 * 20" part should be folded to 100, but "input_val" remains dynamic.
    // Resulting bytecode should look like: PUSHARG, PUSHC(100), ADD
    VAR result = input_val + (5 * 20) 
    RETURN result
END_FUN

VAR mixed_res = mixed_math(50)
STRINGLN    Expr: 50 + (5 * 20)
STRINGLN    Result: $mixed_res%d (Expected: 150)

// ---------------------------------------------------------------------------------
// SECTION 7: LARGE NUMBERS & OVERFLOW
// ---------------------------------------------------------------------------------

STRINGLN [TEST 6] Large Numbers & Overflow Behavior

// Max Signed 32-bit: 2147483647 (0x7FFFFFFF)
VAR max_int = 0x7FFFFFFF
STRINGLN    Value: Max Int
STRINGLN    Result: $max_int%d (Expected: 2147483647)

// Min Signed 32-bit: -2147483648 (0x80000000)
VAR min_int = 0x80000000
STRINGLN    Value: Min Int (0x80000000)
STRINGLN    Result: $min_int%d (Expected: -2147483648)

// Overflow Check: 0x7FFFFFFF + 1 should wrap to 0x80000000 (-2147483648)
// This verifies your optimizer handles 32-bit wrap-around correctly during folding.
VAR overflow_check = 0x7FFFFFFF + 1
STRINGLN    Expr: MAX_INT + 1
STRINGLN    Result: $overflow_check%d (Expected: -2147483648)

STRINGLN --- END OPTIMIZATION TEST ---