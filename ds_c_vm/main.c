#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include "main.h"
#include <setjmp.h>
#include <stdlib.h>
#include <time.h>

uint8_t bin_buf[BIN_BUF_SIZE] __attribute__((aligned(4)));
uint32_t defaultdelay;
uint32_t defaultchardelay;
uint32_t charjitter;
uint32_t rand_min, rand_max;
uint32_t loop_size;
uint8_t epilogue_actions;
uint8_t allow_abort;
uint8_t kb_led_status;
uint8_t disable_autorepeat;
uint32_t pgv_buf[PGV_COUNT];
int16_t utc_offset_minutes;
const uint8_t dsvm_version = 2;
static jmp_buf jmpbuf;
uint8_t current_key_id = 127;

// Platform-specific includes
#if defined(_WIN32) || defined(_WIN64)
    #include <windows.h>
#else
    // _POSIX_C_SOURCE required for nanosleep on some compilers
    #define _POSIX_C_SOURCE 199309L 
    #include <time.h>
#endif

/**
 * Cross-platform sleep function.
 * @param ms The number of milliseconds to sleep.
 */
void delay_ms(uint32_t ms)
{
#if defined(_WIN32) || defined(_WIN64)
    // Windows Sleep() takes milliseconds directly
    Sleep(ms); 
#else
    // POSIX (Linux/macOS) prefers nanosleep
    struct timespec ts;
    ts.tv_sec = ms / 1000;
    ts.tv_nsec = (ms % 1000) * 1000000;
    
    // nanosleep takes a pointer to the request and a pointer to remain
    // (NULL means we don't care about the remaining time if interrupted)
    nanosleep(&ts, NULL);
#endif
}

// ---------------------------

/*
  AUTO GENERATED BY 
  print_C_opcode_len_lookup()
  print_C_opcode_def()
  IN dsvm_common.py
*/
    
#define OP_LEN_LOOKUP_SIZE 100
uint8_t opcode_len_lookup[OP_LEN_LOOKUP_SIZE] = {
1, // [0] NOP
3, // [1] PUSHC16
3, // [2] PUSHI
3, // [3] PUSHR
3, // [4] POPI
3, // [5] POPR
3, // [6] BRZ
3, // [7] JMP
3, // [8] ALLOC
3, // [9] CALL
3, // [10] RET
1, // [11] HALT
1, // [12] PUSH0
1, // [13] PUSH1
1, // [14] DROP
1, // [15] DUP
1, // [16] RANDINT
5, // [17] PUSHC32
2, // [18] PUSHC8
255, // [19]
255, // [20]
255, // [21]
255, // [22]
255, // [23]
1, // [24] PEEK8
1, // [25] PEEKU8
1, // [26] PEEK16
1, // [27] PEEKU16
1, // [28] PEEK32
1, // [29] POKE8
1, // [30] POKE16
1, // [31] POKE32
1, // [32] EQ
1, // [33] NOTEQ
1, // [34] LT
1, // [35] LTE
1, // [36] GT
1, // [37] GTE
1, // [38] ADD
1, // [39] SUB
1, // [40] MULT
1, // [41] DIV
1, // [42] MOD
1, // [43] POW
1, // [44] LSL
1, // [45] ASR
1, // [46] BITOR
1, // [47] BITXOR
1, // [48] BITAND
1, // [49] LOGIAND
1, // [50] LOGIOR
1, // [51] ULT
1, // [52] ULTE
1, // [53] UGT
1, // [54] UGTE
1, // [55] BITINV
1, // [56] LOGINOT
1, // [57] USUB
255, // [58]
255, // [59]
255, // [60]
255, // [61]
255, // [62]
255, // [63]
1, // [64] DELAY
1, // [65] KDOWN
1, // [66] KUP
1, // [67] MSCL
1, // [68] MMOV
1, // [69] SWCF
1, // [70] SWCC
1, // [71] SWCR
1, // [72] STR
1, // [73] STRLN
1, // [74] OLED_CUSR
1, // [75] OLED_PRNT
1, // [76] OLED_UPDE
1, // [77] OLED_CLR
1, // [78] OLED_REST
1, // [79] OLED_LINE
1, // [80] OLED_RECT
1, // [81] OLED_CIRC
1, // [82] BCLR
1, // [83] SKIPP
1, // [84] GOTOP
1, // [85] SLEEP
1, // [86] RANDCHR
1, // [87] PUTS
255, // [88]
1, // [89] HIDTX
255, // [90]
255, // [91]
255, // [92]
255, // [93]
255, // [94]
255, // [95]
255, // [96]
255, // [97]
255, // [98]
255, // [99]
};

#define OP_NOP 0
#define OP_PUSHC16 1
#define OP_PUSHI 2
#define OP_PUSHR 3
#define OP_POPI 4
#define OP_POPR 5
#define OP_BRZ 6
#define OP_JMP 7
#define OP_ALLOC 8
#define OP_CALL 9
#define OP_RET 10
#define OP_HALT 11
#define OP_PUSH0 12
#define OP_PUSH1 13
#define OP_DROP 14
#define OP_DUP 15
#define OP_RANDINT 16
#define OP_PUSHC32 17
#define OP_PUSHC8 18
#define OP_PEEK8 24
#define OP_PEEKU8 25
#define OP_PEEK16 26
#define OP_PEEKU16 27
#define OP_PEEK32 28
#define OP_POKE8 29
#define OP_POKE16 30
#define OP_POKE32 31
#define OP_EQ 32
#define OP_NOTEQ 33
#define OP_LT 34
#define OP_LTE 35
#define OP_GT 36
#define OP_GTE 37
#define OP_ADD 38
#define OP_SUB 39
#define OP_MULT 40
#define OP_DIV 41
#define OP_MOD 42
#define OP_POW 43
#define OP_LSL 44
#define OP_ASR 45
#define OP_BITOR 46
#define OP_BITXOR 47
#define OP_BITAND 48
#define OP_LOGIAND 49
#define OP_LOGIOR 50
#define OP_ULT 51
#define OP_ULTE 52
#define OP_UGT 53
#define OP_UGTE 54
#define OP_BITINV 55
#define OP_LOGINOT 56
#define OP_USUB 57
#define OP_DELAY 64
#define OP_KDOWN 65
#define OP_KUP 66
#define OP_MSCL 67
#define OP_MMOV 68
#define OP_SWCF 69
#define OP_SWCC 70
#define OP_SWCR 71
#define OP_STR 72
#define OP_STRLN 73
#define OP_OLED_CUSR 74
#define OP_OLED_PRNT 75
#define OP_OLED_UPDE 76
#define OP_OLED_CLR 77
#define OP_OLED_REST 78
#define OP_OLED_LINE 79
#define OP_OLED_RECT 80
#define OP_OLED_CIRC 81
#define OP_BCLR 82
#define OP_SKIPP 83
#define OP_GOTOP 84
#define OP_SLEEP 85
#define OP_RANDCHR 86
#define OP_PUTS 87
#define OP_HIDTX 89
#define OP_VMVER 255
// ---------------------------

my_stack data_stack;

// vm_stack_base: The virtual address where stack starts (e.g., 0xF7FF)
void stack_init(my_stack* ms, uint8_t* ram_base, uint16_t vm_stack_base, uint16_t size_bytes)
{
    // 1. Store the host memory base
    ms->ram_base = ram_base;

    // 2. Align the virtual base address (rounding down to nearest 4-byte boundary)
    //    If vm_stack_base is 0xF7FF, this becomes 0xF7FC
    uint16_t aligned_base = vm_stack_base & ~0x03;

    // 3. Set bounds
    ms->upper_bound = aligned_base; 
    ms->lower_bound = aligned_base - size_bytes;

    // 4. Initialize registers
    //    Matches your original logic: SP points to the current empty slot.
    //    We start "one slot down" so the first write occupies the top-most aligned bytes.
    ms->sp = ms->upper_bound - sizeof(uint32_t); 
    ms->fp = ms->upper_bound;

    // 5. Clear memory (Translation: Host Addr = ram_base + virtual_offset)
    memset(ms->ram_base + ms->lower_bound, 0, size_bytes);
}

void stack_push(my_stack* ms, uint32_t in_value)
{
  if (ms->sp < ms->lower_bound) 
    longjmp(jmpbuf, EXE_STACK_OVERFLOW);
  uint8_t* host_addr = ms->ram_base + ms->sp;
  memcpy(host_addr, &in_value, sizeof(uint32_t));
  ms->sp -= sizeof(uint32_t);
}

void stack_pop(my_stack* ms, uint32_t *out_value)
{
  uint16_t next_sp = ms->sp + sizeof(uint32_t);
  if (next_sp >= ms->upper_bound)
    longjmp(jmpbuf, EXE_STACK_UNDERFLOW);
  ms->sp = next_sp;
  uint8_t* host_addr = ms->ram_base + ms->sp;
  if(out_value != NULL)
    memcpy(out_value, host_addr, sizeof(uint32_t));
}

uint32_t stack_peek(my_stack* ms)
{
  // The 'top' of the stack is 4 bytes above the current SP
  uint16_t top_address = ms->sp + sizeof(uint32_t);

  // Check if the stack is empty (Underflow)
  if (top_address >= ms->upper_bound)
    longjmp(jmpbuf, EXE_STACK_UNDERFLOW);

  // Calculate host address and return the value
  uint32_t value;
  uint8_t* host_addr = ms->ram_base + top_address;
  memcpy(&value, host_addr, sizeof(uint32_t));
  
  return value;
}

uint8_t read_byte(uint16_t addr)
{
  if(addr >= BIN_BUF_SIZE)
    longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
  return bin_buf[addr];
}

void write_byte(uint16_t addr, uint8_t value)
{
  if(addr >= BIN_BUF_SIZE)
    longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
  bin_buf[addr] = value;
}

void stack_write_fp_rel(my_stack* ms, int16_t offset, uint32_t value)
{
  if (offset & 0x03)
    longjmp(jmpbuf, EXE_UNALIGNED_ACCESS);
  uint16_t target_addr = ms->fp + offset;
  if (target_addr < ms->lower_bound || target_addr > (ms->upper_bound - sizeof(uint32_t)))
    longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
  uint8_t* host_addr = ms->ram_base + target_addr;
  memcpy(host_addr, &value, sizeof(uint32_t));
}

void stack_read_fp_rel(my_stack* ms, int16_t offset, uint32_t* value)
{
  if (offset & 0x03)
    longjmp(jmpbuf, EXE_UNALIGNED_ACCESS);

  uint16_t target_addr = ms->fp + offset;
  if (target_addr < ms->lower_bound || target_addr > (ms->upper_bound - sizeof(uint32_t)))
    longjmp(jmpbuf, EXE_ILLEGAL_ADDR);

  uint8_t* host_addr = ms->ram_base + target_addr;
  memcpy(value, host_addr, sizeof(uint32_t));
}

void stack_print(my_stack* ms, char* comment)
{
  if(PRINT_DEBUG == 0)
    return;
  printf("\n=== STACK STATE: %s ===\n", comment);
  printf("------------------------\n");

  // 1. Start iteration directly at SP (The Free Slot)
  //    We loop from SP (Low Address) up to Upper Bound (High Address)
  uint16_t current_v_addr = ms->sp;

  // 2. Iterate
  while (current_v_addr <= ms->upper_bound)
  {
    // Translate Virtual Addr -> Host Addr
    uint8_t* host_addr = ms->ram_base + current_v_addr;
    
    // Read value safely (Note: For the free slot, this is technically garbage/uninitialized data)
    uint32_t val;
    memcpy(&val, host_addr, sizeof(uint32_t));

    // Print Line: [Addr]  HexValue
    printf(" [0x%04X]  0x%08X  ", current_v_addr, val);

    // 3. Special handling for the SP (Free Slot) vs Data Slots
    if (current_v_addr == ms->sp) 
    {
      // This is the empty slot waiting for the next push
      printf("<----------------------- SP");
    }
    else 
    {
      // This is actual data
      printf("(%10d)", val);
      // Mark the actual Top of Stack data (the item most recently pushed)
      if (current_v_addr == ms->sp + sizeof(uint32_t))
        printf("  [TOS]");
    }

    // Add visual markers for Frame Pointer
    if (current_v_addr == ms->fp)
      printf(" <--- FP");
    // Mark the Stack Bottom (First item pushed)
    if (current_v_addr == ms->upper_bound)
      printf("  [BOTTOM]");
    printf("\n");
    // Move to the next item (higher address)
    current_v_addr += sizeof(uint32_t);
  }
  printf("========================\n\n");
}

uint32_t binop_equal(uint32_t a, uint32_t b) {return a == b;}
uint32_t binop_not_equal(uint32_t a, uint32_t b) {return a != b;}
uint32_t binop_lower(uint32_t a, uint32_t b)
{
  if(unsigned_math)
    return a < b;
  return (int32_t)a < (int32_t)b;
}
uint32_t binop_lower_eq(uint32_t a, uint32_t b)
{
  if(unsigned_math)
    return a <= b;
  return (int32_t)a <= (int32_t)b;
}
uint32_t binop_greater(uint32_t a, uint32_t b)
{
  if(unsigned_math)
    return a > b;
  return (int32_t)a > (int32_t)b;
}
uint32_t binop_greater_eq(uint32_t a, uint32_t b)
{
  if(unsigned_math)
    return a >= b;
  return (int32_t)a >= (int32_t)b;
}
uint32_t binop_add(uint32_t a, uint32_t b) {return a + b;}
uint32_t binop_sub(uint32_t a, uint32_t b) {return a - b;}
uint32_t binop_mul(uint32_t a, uint32_t b) {return a * b;}
uint32_t binop_mod(uint32_t a, uint32_t b)
{
  if(b == 0)
    longjmp(jmpbuf, EXE_DIVISION_BY_ZERO);
  if(unsigned_math)
    return a % b;
  return (int32_t)a % (int32_t)b;
}
uint32_t binop_lshift(uint32_t a, uint32_t b) {return a << b;}
uint32_t binop_rshift(uint32_t a, uint32_t b)
{
  if(unsigned_math)
    return a >> b;
  return (int32_t)((int32_t)a >> (int32_t)b);
}
uint32_t binop_bitwise_or(uint32_t a, uint32_t b) {return a | b;}
uint32_t binop_bitwise_xor(uint32_t a, uint32_t b) {return a ^ b;}
uint32_t binop_bitwise_and(uint32_t a, uint32_t b) {return a & b;}
uint32_t binop_logical_and(uint32_t a, uint32_t b) {return a && b;}
uint32_t binop_logical_or(uint32_t a, uint32_t b) {return a || b;}
uint32_t binop_divide(uint32_t a, uint32_t b)
{
  if(b == 0)
    longjmp(jmpbuf, EXE_DIVISION_BY_ZERO);
  if(unsigned_math)
    return a / b;
  return (int32_t)a / (int32_t)b; 
}
uint32_t binop_power(uint32_t x, uint32_t exponent)
{
  if (unsigned_math == 0 && ((int32_t)exponent < 0))
    return 0;
  uint32_t result = 1;
  for (size_t i = 0; i < exponent; ++i)
    result *= x;
  return result;
}

uint32_t unaop_bit_inv(uint32_t value) {return ~value;}
uint32_t unaop_logical_not(uint32_t value) {return !value;}
uint32_t unaop_usub(uint32_t value) {return value * -1;}

void binop(FUNC_PTR_BINOP bin_func)
{
  uint32_t rhs, lhs;
  stack_pop(&data_stack, &rhs);
  stack_pop(&data_stack, &lhs);
  stack_push(&data_stack, bin_func(lhs, rhs));
  stack_print(&data_stack, "AFTER BINOP");
}

void unaryop(FUNC_PTR_UNARY una_func)
{
  uint32_t value;
  stack_pop(&data_stack, &value);
  stack_push(&data_stack, una_func(value));
  stack_print(&data_stack, "AFTER UNAOP");
}

uint8_t get_gv_index(uint16_t addr)
{
  uint8_t gv_index = (addr - PGV_START_ADDRESS) / PGV_BYTE_WIDTH;
  if(gv_index >= PGV_COUNT)
    longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
  return gv_index;
}

uint8_t is_pgv(uint16_t addr)
{
  return addr >= PGV_START_ADDRESS && addr <= PGV_END_ADDRESS_INCLUSIVE;
}

uint16_t make_uint16(const uint8_t* base_addr)
{
  uint16_t result;
  memcpy(&result, base_addr, sizeof(result)); 
  return result;
}

uint32_t make_uint32(const uint8_t* base_addr)
{
  uint32_t result;
  memcpy(&result, base_addr, sizeof(result)); 
  return result;
}

void write_uint32_as_4B(uint8_t* bbuf, uint32_t value)
{
  memcpy(bbuf, &value, sizeof(uint32_t));
}

uint32_t memread_u32(uint16_t addr)
{
  if (addr <= USER_VAR_END_ADDRESS_INCLUSIVE)
    return make_uint32(&bin_buf[addr]);
  if (is_pgv(addr))
    return pgv_buf[get_gv_index(addr)];
  if (addr == _DEFAULTDELAY)
	  return defaultdelay;
  if (addr == _DEFAULTCHARDELAY)
    return defaultchardelay;
  if (addr == _CHARJITTER)
    return charjitter;
  if (addr == _RANDOM_MIN)
    return rand_min;
  if (addr == _RANDOM_MAX)
    return rand_max;
  if (addr == _RANDOM_INT && unsigned_math)
    return random_uint32_between(rand_min, rand_max);
  if (addr == _RANDOM_INT && !unsigned_math)
    return (uint32_t)random_int32_between((int32_t)rand_min, (int32_t)rand_max);
  if (addr == _TIME_MS)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _READKEY)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _LOOP_SIZE)
    return loop_size;
  if (addr == _KEYPRESS_COUNT)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _EPILOGUE_ACTIONS)
    return epilogue_actions;
  if (addr == _TIME_S)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _ALLOW_ABORT)
    return allow_abort;
  if (addr == _BLOCKING_READKEY)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _IS_NUMLOCK_ON)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _IS_CAPSLOCK_ON)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _IS_SCROLLLOCK_ON)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _DONT_REPEAT)
    return disable_autorepeat;
  if (addr == _THIS_KEYID)
    return current_key_id;
  if (addr == _DP_MODEL)
    return 2;
  if (addr == _RTC_IS_VALID)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _RTC_UTC_OFFSET)
    return utc_offset_minutes;
  if (addr == _RTC_YEAR)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _RTC_MONTH)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _RTC_DAY)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _RTC_HOUR)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _RTC_MINUTE)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _RTC_SECOND)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _RTC_WDAY)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _RTC_YDAY)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _UNUSED)
    return 0;
  if (addr == _UNSIGNED_MATH)
    return unsigned_math;
  if (addr == _SW_BITFIELD)
    return DUMMY_DATA_REPLACE_ME;
  longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
}

void memwrite_u32(uint16_t addr, uint32_t value)
{
  if (addr <= USER_VAR_END_ADDRESS_INCLUSIVE)
    write_uint32_as_4B(&bin_buf[addr], value);
  else if (is_pgv(addr))
  {
    pgv_buf[get_gv_index(addr)] = value;
    DS_SET_BITS(epilogue_actions, EPI_SAVE_PGV);
  }
  else if (addr == _DEFAULTDELAY)
	  defaultdelay = value;
  else if (addr == _DEFAULTCHARDELAY)
    defaultchardelay = value;
  else if (addr == _CHARJITTER)
    charjitter = value;
  else if (addr == _RANDOM_MIN)
    rand_min = value;
  else if (addr == _RANDOM_MAX)
    rand_max = value;
  else if (addr == _KEYPRESS_COUNT)
    DUMMY_DATA_REPLACE_ME;
  else if (addr == _EPILOGUE_ACTIONS)
    epilogue_actions = value;
  else if (addr == _ALLOW_ABORT)
    allow_abort = value;
  else if (addr == _DONT_REPEAT)
    disable_autorepeat = value;
  else if (addr == _RTC_UTC_OFFSET)
    utc_offset_minutes = value;
  else if (addr == _UNSIGNED_MATH)
    unsigned_math = value;
}

uint8_t load_dsb(char* dsb_path, uint32_t* dsb_size)
{
  FILE *dsb_file = fopen(dsb_path, "rb");
  if(dsb_file == NULL)
    return EXE_DSB_FOPEN_FAIL;
  memset(bin_buf, 0, BIN_BUF_SIZE);
  *dsb_size = fread(bin_buf, 1, BIN_BUF_SIZE, dsb_file);
  fclose(dsb_file);
  if(*dsb_size == 0)
    return EXE_DSB_FREAD_ERROR;
  if(*dsb_size >= MAX_BIN_SIZE)
    return EXE_DSB_FILE_TOO_LARGE;
  if(bin_buf[0] != OP_VMVER)
    return EXE_DSB_INCOMPATIBLE_VERSION;
  if(bin_buf[1] != dsvm_version)
    return EXE_DSB_INCOMPATIBLE_VERSION;
  return EXE_OK;
}

uint8_t str_is_integer(const char *str, long *out_value)
{
  char *endptr;
  long val = strtol(str, &endptr, 0);
  if (str == endptr)
    return 0;
  if (*endptr != '\0')
    return 0;
  if (out_value)
    *out_value = val;    
  return 1;
}

uint8_t inst_size_lookup(uint8_t opcode)
{
  if(opcode == OP_VMVER)
    return 3;
  if(opcode >= OP_LEN_LOOKUP_SIZE || opcode_len_lookup[opcode] > MAX_INSTRUCTION_LEN)
    longjmp(jmpbuf, EXE_ILLEGAL_INSTRUCTION);
  return opcode_len_lookup[opcode];
}

void my_snprintf(const char* format, uint32_t value, char* buf, uint32_t buf_size)
{
  if (buf == NULL || buf_size == 0)
    return;
  if (format == NULL || strlen(format) == 0)
    snprintf(buf, buf_size, "%d", (int32_t)value);
  else 
    snprintf(buf, buf_size, format, value);
}

char* copy_format_specifier(char* src, char* spec_buf, uint8_t spec_buf_size, uint8_t boundary)
{
  memset(spec_buf, 0, spec_buf_size);
  uint8_t i = 0;
  while(1)
  {
    if(src[i] == 0)
      return NULL;
    if(i >= spec_buf_size)
      return NULL;
    if((uint8_t)src[i] == boundary)
      return &src[i];
    spec_buf[i] = src[i];
    i++;
  }
  return NULL;
}

#define MKSTR_BUF_SIZE 32
char make_str_buf[MKSTR_BUF_SIZE];
#define READ_BUF_SIZE (256 * 4)
char read_buffer[READ_BUF_SIZE];
#define FORMAT_SPEC_BUF_SIZE 16
char format_spec_buf[FORMAT_SPEC_BUF_SIZE];

char* make_str(uint16_t str_start_addr)
{
  char* curr_char = (char*)(bin_buf + str_start_addr);
  memset(read_buffer, 0, READ_BUF_SIZE);
  while (1)
  {
    uint8_t this_char = *curr_char;
    if (this_char == 0)
      break;

    if (this_char == MAKESTR_VAR_BOUNDARY_IMM || this_char == MAKESTR_VAR_BOUNDARY_REL)
    {
      uint8_t boundary_type = this_char;
      
      curr_char++; // now at addr LSB
      uint8_t* lsb = (uint8_t*)curr_char;
      curr_char++; // now at addr MSB
      curr_char++; // now at format specifier (if exist), or boundary byte
      
      memset(format_spec_buf, 0, FORMAT_SPEC_BUF_SIZE);
      if (*curr_char != boundary_type)
        curr_char = copy_format_specifier(curr_char, format_spec_buf, FORMAT_SPEC_BUF_SIZE, boundary_type);
      if (curr_char == NULL)
        longjmp(jmpbuf, EXE_STR_ERROR);
      
      curr_char++;

      uint16_t addr_val = make_uint16(lsb);
      uint32_t var_value = 0;

      // Fetch the value based on the boundary type
      if (boundary_type == MAKESTR_VAR_BOUNDARY_IMM)
        var_value = memread_u32(addr_val);
      else
        stack_read_fp_rel(&data_stack, (int16_t)addr_val, &var_value);

      memset(make_str_buf, 0, MKSTR_BUF_SIZE);
      my_snprintf(format_spec_buf, var_value, make_str_buf, MKSTR_BUF_SIZE);
      strcat(read_buffer, make_str_buf);
      continue;
    }

    // Handle Literal Characters
    uint32_t len = strlen(read_buffer);
    if (len < READ_BUF_SIZE - 1)
    {
      read_buffer[len] = this_char;
      read_buffer[len + 1] = '\0';
    }
    curr_char++;
  }
  return read_buffer;
}

#define RANDCHR_LOWER (1 << 0) // 1
#define RANDCHR_UPPER (1 << 1) // 2
#define RANDCHR_DIGITS       (1 << 2) // 4
#define RANDCHR_SYMBOLS      (1 << 3) // 8
#define RANDCHR_PRINT_KB (1 << 0) // 1
#define RANDCHR_PRINT_OLED (1 << 1) // 2

const char* chr_upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const char* chr_lower = "abcdefghijklmnopqrstuvwxyz";
const char* chr_nums  = "0123456789";
const char* chr_syms  = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}";
#define RANDCHAR_POOL_SIZE 128
char randchar_pool[RANDCHAR_POOL_SIZE];

char get_random_char(uint8_t bitmask)
{
  memset(randchar_pool, 0, RANDCHAR_POOL_SIZE);
  if (bitmask & RANDCHR_UPPER) strcat(randchar_pool, chr_upper);
  if (bitmask & RANDCHR_LOWER) strcat(randchar_pool, chr_lower);
  if (bitmask & RANDCHR_DIGITS) strcat(randchar_pool, chr_nums);
  if (bitmask & RANDCHR_SYMBOLS) strcat(randchar_pool, chr_syms);
  uint32_t pool_size = strlen(randchar_pool);
  if (pool_size == 0)
    return 0;
  return randchar_pool[rand() % pool_size];
}

// USE ESP32 BUILT IN RANDOM FUNCTION
uint32_t arc4random(void)
{
  uint32_t r = 0;
  r |= (uint32_t)rand() & 0xFF;
  r |= ((uint32_t)rand() & 0xFF) << 8;
  r |= ((uint32_t)rand() & 0xFF) << 16;
  r |= ((uint32_t)rand() & 0xFF) << 24;
  return r;
}

uint32_t arc4random_uniform(uint32_t range)
{
  return range ? arc4random() % range : 0;
}

uint32_t random_uint32_between(uint32_t lower, uint32_t upper)
{
  if (lower > upper) { uint32_t tmp = lower; lower = upper; upper = tmp; }
  uint64_t range = (uint64_t)upper - (uint64_t)lower + 1;
  if (range >> 32) 
    return arc4random(); 
  return lower + arc4random_uniform((uint32_t)range);
}

int32_t random_int32_between(int32_t lower, int32_t upper)
{
  if (lower > upper) { int32_t tmp = lower; lower = upper; upper = tmp; }
  int64_t range = (int64_t)upper - (int64_t)lower + 1;
  if (range >= 0x100000000LL)
    return (int32_t)arc4random();
  return lower + (int32_t)arc4random_uniform((uint32_t)range);
}

void execute_instruction(exe_context* exe)
{
  uint16_t curr_pc = exe->this_pc;
  uint8_t opcode = read_byte(curr_pc);
  uint8_t instruction_size_bytes = inst_size_lookup(opcode);
  uint32_t payload = 0;
  exe->next_pc += instruction_size_bytes;
  
  if(instruction_size_bytes == 2)
    payload = bin_buf[curr_pc + 1];
  else if(instruction_size_bytes == 3)
    payload = make_uint16(bin_buf + curr_pc + 1);
  else if(instruction_size_bytes == 5)
    payload = make_uint32(bin_buf + curr_pc + 1);
  
  if(PRINT_DEBUG)
  {
    printf("\n--------------------\n");
    printf("PC: %04d    Opcode: %02d    Payload: %04x", curr_pc, opcode, payload);
    printf("\n");
  }

  if(opcode == OP_NOP || opcode == OP_VMVER)
  {
    return;
  }
  else if(opcode == OP_PUSHC16 || opcode == OP_PUSHC32 || opcode == OP_PUSHC8)
  {
    stack_push(&data_stack, payload);
    stack_print(&data_stack, "AFTER PUSHC");
  }
  else if(opcode == OP_PUSHI)
  {
    stack_push(&data_stack, memread_u32(payload));
    stack_print(&data_stack, "AFTER PUSHI");
  }
  else if(opcode == OP_PUSHR)
  {
    uint32_t this_value;
    stack_read_fp_rel(&data_stack, (int16_t)payload, &this_value);
    stack_push(&data_stack, this_value);
    stack_print(&data_stack, "AFTER PUSHR");
  }
  else if(opcode == OP_POPI)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    memwrite_u32(payload, this_value);
    stack_print(&data_stack, "AFTER POPI");
  }
  else if(opcode == OP_POPR)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    stack_write_fp_rel(&data_stack, (int16_t)payload, this_value);
    stack_print(&data_stack, "AFTER POPR");
  }
  else if(opcode == OP_BRZ)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    if(this_value == 0)
      exe->next_pc = payload;
  }
  else if(opcode == OP_JMP)
  {
    exe->next_pc = payload;
  }
  else if(opcode == OP_ALLOC)
  {
    for (size_t i = 0; i < payload; i++)
      stack_push(&data_stack, 0);
    stack_print(&data_stack, "After ALLOC");
  }
  else if(opcode == OP_CALL)
  {
    uint32_t frame_info = (data_stack.fp << 16) | (curr_pc + instruction_size_bytes);
    stack_push(&data_stack, frame_info);
    data_stack.fp = data_stack.sp + sizeof(uint32_t);
    stack_print(&data_stack, "CALL");
    exe->next_pc = payload;
  }
  else if(opcode == OP_RET)
  {
    stack_print(&data_stack, "RET");
    // stash return value
    uint32_t func_return_val;
    stack_pop(&data_stack, &func_return_val);
    // pop until frame_info is on TOS
    while(1)
    {
      if(data_stack.sp + sizeof(uint32_t) == data_stack.fp)
        break;
      stack_pop(&data_stack, NULL);
    }
    // pop frame_info and restore PC and FP
    uint32_t frame_info;
    stack_pop(&data_stack, &frame_info);
    data_stack.fp = (frame_info >> 16) & 0xffff;
    exe->next_pc = frame_info & 0xffff;
    // pop off arguments
    for (size_t i = 0; i < payload; i++)
      stack_pop(&data_stack, NULL);
    // push return value back on stack
    stack_push(&data_stack, func_return_val);
    stack_print(&data_stack, "UNWIND DONE");
  }
  else if(opcode == OP_HALT)
  {
    exe->result = EXE_HALT;
  }
  else if(opcode == OP_PEEK8)
  {
    uint32_t target_addr;
    stack_pop(&data_stack, &target_addr);
    uint8_t data = read_byte((uint16_t)target_addr);
    stack_push(&data_stack, (uint32_t)data);
  }
  else if(opcode == OP_POKE8)
  {
    uint32_t target_value, target_addr;
    stack_pop(&data_stack, &target_addr);
    stack_pop(&data_stack, &target_value);
    write_byte((uint16_t)target_addr, (uint8_t)target_value);
  }
  else if(opcode == OP_PUSH0)
  {
    stack_push(&data_stack, 0);
  }
  else if(opcode == OP_PUSH1)
  {
    stack_push(&data_stack, 1);
  }
  else if(opcode == OP_DROP)
  {
    stack_pop(&data_stack, NULL);
  }
  else if(opcode == OP_DUP)
  {
    uint32_t topval = stack_peek(&data_stack);
    stack_push(&data_stack, topval);
  }
  else if(opcode == OP_RANDINT)
  {
    uint32_t lower, upper;
    stack_pop(&data_stack, &lower);
    stack_pop(&data_stack, &upper);
    // printf("unsigned: %d lower: %u, upper %u\n", unsigned_math, lower, upper);
    if(unsigned_math)
      stack_push(&data_stack, random_uint32_between(lower, upper));
    else
      stack_push(&data_stack, (uint32_t)random_int32_between(lower, upper));
  }
  //--------------------------------------------------------
  else if(opcode == OP_EQ)
  {
    binop(binop_equal);
  }
  else if(opcode == OP_NOTEQ)
  {
    binop(binop_not_equal);
  }
  else if(opcode == OP_LT)
  {
    binop(binop_lower);
  }
  else if(opcode == OP_LTE)
  {
    binop(binop_lower_eq);
  }
  else if(opcode == OP_GT)
  {
    binop(binop_greater);
  }
  else if(opcode == OP_GTE)
  {
    binop(binop_greater_eq);
  }
  else if(opcode == OP_ADD)
  {
    binop(binop_add);
  }
  else if(opcode == OP_SUB)
  {
    binop(binop_sub);
  }
  else if(opcode == OP_MULT)
  {
    binop(binop_mul);
  }
  else if(opcode == OP_DIV)
  {
    binop(binop_divide);
  }
  else if(opcode == OP_MOD)
  {
    binop(binop_mod);
  }
  else if(opcode == OP_POW)
  {
    binop(binop_power);
  }
  else if(opcode == OP_LSHIFT)
  {
    binop(binop_lshift);
  }
  else if(opcode == OP_RSHIFT)
  {
    binop(binop_rshift);
  }
  else if(opcode == OP_BITOR)
  {
    binop(binop_bitwise_or);
  }
  else if(opcode == OP_BITXOR)
  {
    binop(binop_bitwise_xor);
  }
  else if(opcode == OP_BITAND)
  {
    binop(binop_bitwise_and);
  }
  else if(opcode == OP_LOGIAND)
  {
    binop(binop_logical_and);
  }
  else if(opcode == OP_LOGIOR)
  {
    binop(binop_logical_or);
  }
  else if(opcode == OP_BITINV)
  {
    unaryop(unaop_bit_inv);
  }
  else if(opcode == OP_LOGINOT)
  {
    unaryop(unaop_logical_not);
  }
  else if(opcode == OP_USUB)
  {
    unaryop(unaop_usub);
  }
  else if(opcode == OP_DELAY)
  {
    uint32_t amount;
    stack_pop(&data_stack, &amount);
    printf("OP_DELAY: %dms\n", amount);
    delay_ms(amount);
  }
  else if(opcode == OP_KDOWN)
  {
    uint32_t combocode;
    stack_pop(&data_stack, &combocode);
    printf("OP_KDOWN: %d\n", combocode);
  }
  else if(opcode == OP_KUP)
  {
    uint32_t combocode;
    stack_pop(&data_stack, &combocode);
    printf("OP_KUP: %d\n", combocode);
  }
  else if(opcode == OP_MSCL)
  {
    uint32_t hlines, vlines;
    stack_pop(&data_stack, &hlines);
    stack_pop(&data_stack, &vlines);
    printf("OP_MSCL: %d %d\n", hlines, vlines);
  }
  else if(opcode == OP_MMOV)
  {
    uint32_t tempx, tempy;
    stack_pop(&data_stack, &tempx);
    stack_pop(&data_stack, &tempy);
    printf("OP_MMOV: %d %d\n", tempx, tempy);
  }
  else if(opcode == OP_SWCF)
  {
    uint32_t red, green, blue;
    stack_pop(&data_stack, &red);
    stack_pop(&data_stack, &green);
    stack_pop(&data_stack, &blue);
    printf("OP_SWCF: %d %d %d\n", red, green, blue);
    DS_SET_BITS(epilogue_actions, EPI_SAVE_COLOR_STATE);
  }
  else if(opcode == OP_SWCC)
  {
    uint32_t this_index, red, green, blue;
    stack_pop(&data_stack, &this_index);
    stack_pop(&data_stack, &red);
    stack_pop(&data_stack, &green);
    stack_pop(&data_stack, &blue);
    printf("OP_SWCC: %d %d %d %d\n", this_index, red, green, blue);
    DS_SET_BITS(epilogue_actions, EPI_SAVE_COLOR_STATE);
  }
  else if(opcode == OP_SWCR)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    printf("OP_SWCR: %d\n", this_value);
    DS_CLEAR_BITS(epilogue_actions, EPI_SAVE_COLOR_STATE);
  }
  else if(opcode == OP_STR)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    char* str_buf = make_str((uint16_t)this_value);
    printf(">>>>> STRING: %s\n", str_buf);
  }
  else if(opcode == OP_STRLN)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    char* str_buf = make_str((uint16_t)this_value);
    printf(">>>>> STRINGLN: %s\n", str_buf);
  }
  else if(opcode == OP_OLED_CUSR)
  {
    uint32_t xxx, yyy;
    stack_pop(&data_stack, &xxx);
    stack_pop(&data_stack, &yyy);
    printf("OP_OLED_CUSR: %d %d\n", xxx, yyy);
  }
  else if(opcode == OP_OLED_PRNT)
  {
    uint32_t opts, addr;
    stack_pop(&data_stack, &opts);
    stack_pop(&data_stack, &addr);
    char* str_buf = make_str((uint16_t)addr);
    printf(">>>>> OLED_PRINT%d: %s\n", opts, str_buf);
  }
  else if(opcode == OP_OLED_UPDE)
  {
    printf("OP_OLED_UPDE\n");
    DS_SET_BITS(epilogue_actions, EPI_RESTORE_OLED);
  }
  else if(opcode == OP_OLED_CLR)
  {
    printf("OP_OLED_CLR\n");
  }
  else if(opcode == OP_OLED_REST)
  {
    printf("OP_OLED_REST\n");
    // user already restored OLED content, no need to do it again.
    DS_CLEAR_BITS(epilogue_actions, EPI_RESTORE_OLED);
  }
  else if(opcode == OP_OLED_LINE)
  {
    uint32_t x1,y1,x2,y2;
    stack_pop(&data_stack, &x1);
    stack_pop(&data_stack, &y1);
    stack_pop(&data_stack, &x2);
    stack_pop(&data_stack, &y2);
    printf("OP_OLED_LINE: %d %d %d %d\n", x1, y1, x2, y2);
  }
  else if(opcode == OP_OLED_RECT)
  {
    uint32_t x1,y1,x2,y2,fill;
    stack_pop(&data_stack, &x1);
    stack_pop(&data_stack, &y1);
    stack_pop(&data_stack, &x2);
    stack_pop(&data_stack, &y2);
    stack_pop(&data_stack, &fill);
    printf("OP_OLED_RECT: %d %d %d %d %d\n", x1, y1, x2, y2, fill);
  }
  else if(opcode == OP_OLED_CIRC)
  {
    uint32_t x,y,radius,fill;
    stack_pop(&data_stack, &x);
    stack_pop(&data_stack, &y);
    stack_pop(&data_stack, &radius);
    stack_pop(&data_stack, &fill);
    printf("OP_OLED_CIRC: %d %d %d %d\n", x, y, radius, fill);
  }
  else if(opcode == OP_BCLR)
  {
    printf("OP_BCLR\n");
  }
  else if(opcode == OP_SKIPP)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    printf("OP_SKIPP: %d\n", this_value);
  }
  else if(opcode == OP_GOTOP)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    char* str_buf = make_str((uint16_t)this_value);
    uint8_t is_int = str_is_integer(str_buf, NULL);
    printf("OP_GOTOP_STR %d: %s\n", is_int, str_buf);
  }
  else if(opcode == OP_SLEEP)
  {
    printf("OP_SLEEP\n");
  }
  else if(opcode == OP_RANDCHR)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    uint8_t char_type = this_value & 0xff;
    uint8_t channels = (this_value >> 8) & 0xff;
    char randc = get_random_char(char_type);
    printf("OP_RANDCHR %x: %c\n", channels, randc);
  }
  else if(opcode == OP_PUTS)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    uint16_t str_addr = this_value & 0xffff;
    uint16_t nchar = (this_value >> 16) & 0xfff;
    uint8_t channels = this_value >> 30;
    // printf("PUTS: Addr 0x%08x nchar: %d, channels: %d\n", str_addr, nchar, channels);
    printf(">>>>> PUTS: %s\n", bin_buf + str_addr);
  }
  else if(opcode == OP_HIDTX)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    printf("OP_HIDTX: %08x\n", this_value);
  }
  else
  {
    printf("Unimplemented opcode: %d\n", opcode);
    longjmp(jmpbuf, EXE_ILLEGAL_INSTRUCTION);
  }
}

void run_dsb(exe_context* ctx, char* dsb_path)
{
  uint32_t this_dsb_size = 0;
  uint8_t dsb_load_result = load_dsb(dsb_path, &this_dsb_size);
  if(dsb_load_result)
  {
    printf("DSB load fail: %d\n", dsb_load_result);
    ctx->result = dsb_load_result;
    return;
  }

  uint16_t data_stack_size_bytes = STACK_BASE_ADDR - this_dsb_size - STACK_MOAT_BYTES;
  stack_init(&data_stack, bin_buf, STACK_BASE_ADDR, data_stack_size_bytes);

  defaultdelay = DEFAULT_CMD_DELAY_MS;
  defaultchardelay = DEFAULT_CHAR_DELAY_MS;
  charjitter = 0;
  rand_max = 0xffff;
  rand_min = 0;
  loop_size = 0;
  epilogue_actions = 0;
  allow_abort = 0;
  disable_autorepeat = 0;

  int panic_code = setjmp(jmpbuf);
  if(panic_code != 0)
  {
    printf("VM Crashed! Panic: %d\n", panic_code);
    ctx->result = panic_code;
    return;
  }
  
  while(1)
  {
    execute_instruction(ctx);
    ctx->this_pc = ctx->next_pc;
    if(ctx->result != EXE_OK)
      break;
    if(ctx->this_pc > this_dsb_size)
      break;
  }
  printf("Execution Complete\n\n");
  disable_autorepeat ? DS_SET_BITS(epilogue_actions, EPI_NO_AUTOREPEAT) : DS_CLEAR_BITS(epilogue_actions, EPI_NO_AUTOREPEAT);
}

void exe_ctx_init(exe_context* ctx)
{
  ctx->result = EXE_OK;
  ctx->this_pc = 0;
  ctx->next_pc = 0;
  ctx->data = 0;
  ctx->epilogue_actions = 0;
}

void print_exe_context(exe_context *ctx) {
  if (ctx == NULL) return;
  printf("--- Execution Context ---\n");
  printf("Result:           %u\n", ctx->result);
  printf("Current PC:       %u\n", ctx->this_pc);
  printf("Next PC:          %u\n", ctx->next_pc);
  printf("Data:             %u\n", ctx->data);
  printf("Epilogue Actions: 0x%02X\n", ctx->epilogue_actions);
  printf("-------------------------\n");
}

int main(int argc, char *argv[])
{
  if (argc < 2)
  {
    fprintf(stderr, "Usage: %s dsb_file\n", argv[0]);
    return 1;
  }
  srand(time(NULL));
  char *file_path = argv[1];
  exe_context exe_ctx;
  exe_ctx_init(&exe_ctx);
  run_dsb(&exe_ctx, file_path);
  print_exe_context(&exe_ctx);
  return 0;
}